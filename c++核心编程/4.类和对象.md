C++面向对象的三大特性：封装、继承、多态

C++认为万事万物都皆为对象，对象上有其属性和行为。具有相同属性的对象，我们可以抽象为类

## 封装
封装的意义：
- 将属性和行为作为一个整体，表现生活中的事物

```c++
//设计一个圆类，求周长
#include<iostream>
using namespace std;
const double PI=3.14;
class Circle
{
private:
    /* data */
public://公共权限
int m_r;

double calculate(){
    return 2*PI*m_r;
}
};

int main(){
    Circle circle;
    circle.m_r=10;
    double c = circle.calculate();
    cout<<c<<endl;
    return 1;
}

```

- 将属性和行为加以权限控制
可以把属性和行为放在不同的权限下，加以控制。访问权限有三种：
	- **public**：公共权限，成员类内可以访问，类外可以访问
	- **protected**:保护权限，成员类内可以访问，类外不可以访问 儿子也可以访问父亲的保护内容
	- **private**：私有权限，成员类内可以访问，类外不可以访问 儿子不可以访问父亲的保护内容

### struct和class的区别
唯一区别在于默认的访问权限不同，struct默认权限为公共，class默认权限为**私有（private）**


### 成员属性设为私有
1. 将所有成员属性设为私有，可以自己控制读写权限
2. 对于写权限，我们可以检测数据的有效性


## 对象的初始化和清理

### 构造函数和析构函数

**构造函数**：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
**析构函数**：主要是在对象销毁前自动调用，执行一些清理工作

```ad-note

构造函数语法：`类名(){}`
1. 构造函数，没有返回值不写void
2. 函数名称和类名相同
3. 构造函数**可以有参数**，因此可以发生重载
4. 程序在调用对象的时候会自动调用构造，无需手动调用，而且只会调用一次

析构函数语法:`~类名(){}`
1. 没有返回值，也不写void
2. 函数名称与类名相同，在名称前面添加～
3. **不可以有参数**，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

```

示例：
```c++
#include<iostream>
using namespace std;

class Person{
public:
    //  构造函数
    Person(){
        cout<<"构造函数的调用"<<endl;
    }
    // 析构函数
    ~Person(){
        cout<<"调用析构函数"<<endl;
    }
};****
void test01(){
    Person p;
}

int main(){
    test01();
    return 1;
}
```


### 构造函数的分类和调用

两种分类方式：
- 按参数分类：有参构造和无参构造
- 按类型分类：普通构造和拷贝构造

三种调用方式：
- 括号法
- 显示法
- 隐式转换法

```C++
#include<iostream>
using namespace std;

class Person{
public:
    //  无参构造函数(默认构造函数)
    Person(){
        cout<<"无参构造函数的调用"<<endl;
    }
// 有参构造函数
    Person(int a){
        age=a;
        cout<<"有参构造函数的调用"<<endl;
    }

    // 拷贝构造函数
    Person(const Person &p){
        age=p.age;
        cout<<"拷贝构造函数的调用"<<endl;
    }
    // 析构函数
    ~Person(){
        cout<< "调用析构函数"<<endl;
    }

    int age;
};
void test01(){
    // 括号法：构造默认构造函数的时候不要添加"()",因为编译器会认为是函数的声明
    Person p;//默认构造函数的调用
    Person p1(10);
    Person p2(p1);

    // 显示法
    Person sp;
    Person sp1=Person(10);
    // 注意：不要利用拷贝构造函数初始化匿名对象，编译器会认为Person(p3)=== Person p3,被认为是对象的声明;
    Person(p3);

    // 隐式转换法
    Person p4=10;//相当于写了Peroson p4 = Person(10);
}

int main(){
    test01();
    return 1;
}
```


### 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况
- 使用一个创建完毕的对象来初始化一个新对象
- 值传递的方式给函数参数传值
- 以值方式返回局部对象

```C++
#include<iostream>
using namespace std;

class Person{
public:
    //  无参构造函数(默认构造函数)
    Person(){
        cout<<"无参构造函数的调用"<<endl;
    }
// 有参构造函数
    Person(int a){
        age=a;
        cout<<"有参构造函数的调用"<<endl;
    }

    // 拷贝构造函数
    Person(const Person &p){
        age=p.age;
        cout<<"拷贝构造函数的调用"<<endl;
    }
    // 析构函数
    ~Person(){
        cout<< "调用析构函数"<<endl;
    }

    int age=10;
};

// 使用一个已经创建完毕的对象来初始化一个新对象
void test01(){
    Person p1(20);
    Person p2(p1);
}

void doWork(Person p){

}
// 值传递的方式给函数参数传值
void test02(){
    Person p;
    doWork(p);
}
Person doWork2(){
    Person pp;
    return pp;
}
void test03(){
    Person p =doWork2();
}

int main(){
    test03();
    return 1;
}
```

### 构造函数调用规则

默认情况下，c++编译器至少给一个类添加三个函数
- 默认构造函数(无参，函数体为空)
- 默认析构函数(无参，函数体为空)
- 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：
- 如果用户定义有参构造函数，c++不再提供默认无参构造，但是会默认拷贝构造
```C++
#include<iostream>
using namespace std;

class Person{
public:
    //  无参构造函数(默认构造函数)
    // Person(){
    //     cout<<"无参构造函数的调用"<<endl;
    // }
// 有参构造函数
    Person(int a){
        age=a;
        cout<<"有参构造函数的调用"<<endl;
    }

    // 拷贝构造函数
    // Person(const Person &p){
    //     age=p.age;
    //     cout<<"拷贝构造函数的调用"<<endl;
    // }
    // 析构函数
    ~Person(){
        cout<< "调用析构函数"<<endl;
    }

    int age=10;
};
void test01(){
    Person p1(20);
    Person p2(p1);
    cout<<p2.age<<endl;
}
int main(){
    test01();
    return 1;
}
```
输出结果：
![[Pasted image 20230808200439.png]]


- 如果用户定义拷贝构造函数，c++不会再提供其他构造函数
```c++
#include<iostream>
using namespace std;

class Person{
public:
    //  无参构造函数(默认构造函数)
    // Person(){
    //     cout<<"无参构造函数的调用"<<endl;
    // }
// 有参构造函数
    // Person(int a){
    //     age=a;
    //     cout<<"有参构造函数的调用"<<endl;
    // }

    // 拷贝构造函数
    Person(const Person &p){
        age=p.age;
        cout<<"拷贝构造函数的调用"<<endl;
    }
    // 析构函数
    ~Person(){
        cout<< "调用析构函数"<<endl;
    }

    int age=10;
};
void test01(){
    Person p;//报错
    Person p1(20);//报错
    Person p2(p1);
    cout<<p2.age<<endl;
}
int main(){
    test01();
    return 1;
}
```

### 深拷贝与浅拷贝
浅拷贝：简单的赋值拷贝操作
深拷贝：在堆区重新申请空间，进行拷贝操作

PS：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

### 初始化列表
作用：C++提供了初始化列表语法，用来初始化属性

语法：`构造函数():属性(值1),属性2(值2)...{}`
```C++
class Person{
public:
    Person(int m_a,int m_b,int m_c):a(m_a),b(m_b),c(m_c){

    }

    int a;
    int b;
    int c;
};

void test(){
    Person p(30,20,10);
    cout<<p.a<<endl;
}

int main(){
    test();
}
```


### 类对象作为类成员
C++类中成员可以是另一个类的对象，我们称之为对象成员
```C++
class A{}
class B{
 A a;
}
```
A为对象成员

当创建B对象时，A与B构造和析构的顺序是谁先谁后？
A比B先构造，但是B比A先析构

### 静态成员
静态成员就是在成员变量和成员函数前加上关键词static，成为静态成员

静态成员分为：

- **静态成员变量**
	- 所有对象共享同一份数据
	- 在编译阶段分配内存
	- 类内声明，类外初始化

```C++
#include<iostream>
using namespace std;

// 静态成员变量
class Person{
    public:
    //在编译阶段分配内存
    static int m_A;

};
// 类内声明，类外初始化操作
int Person::m_A=100;
int main(){
    Person p;
    cout<<p.m_A<<endl;//100

    Person p2;
    p2.m_A=200;
    // 所有对象共享同一份数据
    cout<<p.m_A<<endl;//200
    return 1;
}
```
由于静态成员变量不属于某一个对象上面，所有对象都共享同一份数据。因此静态成员变量有两种方式
因此静态成员变量有两种访问方式
1. 通过对象进行访问
```C++
Person p;
cout<<p.m_A<<endl;
```
2. 通过类名进行访问
```C++
cout<<Person::m_A<<endl;
```

静态成员变量也是有访问权限的。
```C++
// 静态成员变量
class Person{
    public:
    //在编译阶段分配内存
    static int m_A;

    private:
    static int m_B;

};
// 类内声明，类外初始化操作
int Person::m_A=100;
int Person::m_B=100;
int main(){
    Person p;
    cout<<p.m_B<<endl;//报错。类外访问不到
    return 1;
}
```

- **静态成员函数**
	- 所有对象共享同一个函数
	- 静态成员函数只能访问静态成员变量

```C++
// 静态成员函数
class Person{
    public:
    static void func(){
        m_A=100;
        m_B=100;//报错，非静态成员变量不可以访问。无法区分是哪个对象的属性。
        cout<<"静态成员函数调用"<<endl;
    }
    
    static int m_A;
    int m_B;


    private:
    static void func2(){
        cout<<"静态成员函数func2调用"<<endl;
    }
};

int main(){
    // 通过对象访问
    Person p;
    p.func();

    // 通过类名访问
    Person::func();

    Person::func2();//报错，类外访问不到私有静态成员函数
    return 1;
}
```

## C++对象模型和this指针

### 成员变量和成员函数分开存储
在c++中，类内的成员变量和成员函数分开存储
只有**非静态成员变量**才属于类的对象上，非静态成员函数**不属于**类对象上。
```C++
class Person{
    int m_A;//非静态成员变量

    static int m_B;

};

void test01(){
    Person p;
    // 空对象占用内存空间为1
    //c++编译器会给每个空对象分配一个字节，为了区分空对象占内存的位置
    cout<<"size of p = "<<sizeof(p)<<endl;
}

void test02(){
    Person p;
    // 包含一个非静态成员变量，每个对象大小变为4字节
    cout<<"size of p = "<<sizeof(p)<<endl;
}

void test03(){
    Person p;
    // 包含一个静态成员变量，每个对象大小仍然为4字节，这是因为静态成员变量是分开存储的
    cout<<"size of p = "<<sizeof(p)<<endl;
}
void test04(){
    Person p;
    // 添加非静态成员函数，每个对象大小仍然为4字节，这是因为非静态成员函数也是分开存储的
    cout<<"size of p = "<<sizeof(p)<<endl;
}
int main(){
    test03();
    return 1;
}
```

### this指针概念
通过上面我们知道C++中成员变量和成员函数是分开存储的。每个非静态成员函数只会诞生一份函数实例，也就是说多个类型的对象会共用一份代码。
**那么：这一块代码是如何区分哪个对象调用自己呢?**
在C++中，通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属对象。
- this指针是隐含每一个非静态成员函数内的一个指针
- this指针不需要定义，直接使用即可
- this的本质是**指针常量**，即指针指向是**不可以修改**的
this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
- 当类的非静态成员函数中返回对象本身，可以使用`return *this`
```C++
class Person{
public:
    Person(int age){
        // 同名时，this可以用于区分;this指向被调用的成员函数所属对象
        this->age=age;
    }
//返回的Person类型如果不加引用的话，结果为20；这是因为每次返回都会触发对象复制构造函数，创建一个临时对象.
    Person& PersonAddAge(Person &p){
        this->age+=p.age;
        return *this;
    }

    int age;

};

void test01(){
    Person p(23);
    cout<<"年龄为："<<p.age<<endl;
}

void test02(){
    Person p1(10);
    Person p2(10);
    // 链式编程思想
    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);
    cout<<"年龄为:"<<p2.age<<endl;
}

void test03(){
}
int main(){
    test02();
    return 1;
}
```

### 空指针访问成员函数

空指针可以访问成员函数，如果访问加this的成员，需要添加一个if代码来确保对象指针不为空。

### const修饰成员函数

常函数：
- 成员函数后加const后我们称之为常函数
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，常函数中依然可以修改
常对象：
- 声明对象前加const称为常对象
- 常对象只能调用常函数
```C++
class Person{
public:
// 首先this的本质是一个指针常量，也就是指针的指向是不可以修改的
// 在成员函数后面加const，修饰的是this的指向，让指针指向的值也不可以修改，相当于：const Person* const this;
    void showPerson()const{
        this->m_Age=100;//报错
        this->m_B=100;
    }

    int m_Age=10;
    mutable int m_B=10;//特殊变量，即使在常函数中，也可以修改这个值

};

void test01(){
    Person p;
    p.showPerson();
}

void test02(){
    // 常对象
    const Person p;
   
    p.m_Age=1;//这个不可以修改，报错
    p.m_B=200;//尽管这是特殊值，但是在常对象下也可以修改
    p.showPerson();//常对象只可以调用常函数

}
int main(){
    
    return 1;
}
```

## 友元
友元的目的是让一个函数或者类访问另一个类中的私有成员，关键字为`friend`

友元的三种实现：
- 全局函数做友元

```C++
class Room
{
    friend void GoodGay(Room *room);
private:
    /* data */
    string bedroom;
public:
    string livingroom;;
    Room(/* args */){
        this->livingroom="客厅";
        this->bedroom="卧室";
    }
};

void GoodGay(Room *room){
    cout<<"你的好朋友正在访问:"<<room->livingroom<<endl;
    cout<<"你的好朋友正在访问:"<<room->bedroom<<endl;
}

int main(){
    Room room;
    GoodGay(&room);
    return 1;
}
```
- 类做友元
```C++
class Room;
class GoodFriends{
public :
    GoodFriends();
    void visit();
    Room *room;
};

class Room{
//告诉编译器，GoodFriends是Room的好朋友，可以访问到Room类的私有内容
    friend GoodFriends;
public:
    Room();
    string livingroom;

private:   
    string bedroom;
};

//类外写成员函数
Room::Room(){
    livingroom="客厅";
    bedroom="卧室";
}

GoodFriends::GoodFriends(){
    // 创建房间的对象
    room=new Room;
}

void GoodFriends::visit(){
    cout<<"好朋友访问了："<<room->livingroom<<endl;
    cout<<"好朋友访问了："<<room->bedroom<<endl;
    
}

void test(){
    GoodFriends gf;
    gf.visit();
}
int main(){
    test();
    return 1;
}
```
- 成员函数做友元
```C++
class Room;
class GoodFriends{
public :
    GoodFriends();
    void visit();//让visit访问到room中的私有成员
    Room *room;


};

class Room{

    // 告诉编译器，这是GoodFriends类下的visit成员函数作为本类的好朋友，可以访问他的私有内容 
    friend void GoodFriends::visit();
public:
    Room();
    string livingroom;

private:   
    string bedroom;
};

//类外实现成员函数
Room::Room(){
    livingroom="客厅";
    bedroom="卧室";
}

GoodFriends::GoodFriends(){
    // 创建房间的对象
    room=new Room;
}

void GoodFriends::visit(){
    cout<<"好朋友访问了："<<room->livingroom<<endl;
    cout<<"好朋友访问了："<<room->bedroom<<endl;
    
}

void test(){
    GoodFriends gf;
    gf.visit();
}
int main(){
    test();
    return 1;
}
```

## 运算符重载
概念：对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型
### 加号运算符重载
作用：实现两个自定义类型相加的运算
```C++
class Person{
public:
    string name;
    int age;
    // 成员函数重载+号
    // Person operator+(Person &p){
    //     Person tmp;
    //     tmp.age=this->age+p.age;
    //     return tmp;
    // }
    
};
// void test(){
//     Person p1;
//     p1.age=10;
//     Person p2;
//     p2.age=20;

//     Person p3;
//     p3=p1+p2;

//     cout<<p3.age<<endl;
    
// }

// 全局函数重载+号

Person operator+(Person &p1,Person &p2){
    Person tmp;
    tmp.age=p1.age+p2.age;
    return tmp;
}

void test2(){
    Person p1;
    p1.age=10;
    Person p2;
    p2.age=20;

    Person p3;
    p3=p1+p2;

    cout<<p3.age<<endl;
}
int main(){
    test2();
    return 1;
}
```

### 左移运算符重载
可以输出自定义数据类型
```C++
class Person{
    friend ostream& operator<<(ostream& cout,Person& p);
private:
    int m_A;
    int m_B;
    
};

ostream& operator<<(ostream& cout,Person& p){
    p.m_A=10;
    p.m_B=10;
    cout<<"m_A = "<<p.m_A<<" m_B = "<<p.m_B<<endl;
    return cout;
}
void test(){
    Person p;
    cout<<p<<endl;
}

int main(){
    test();
    return 1;
}
```

### 递增运算符重载
作用：通过重载递增运算符，实现自己的整型数据
```C++
class MyInteger
{
    friend ostream &operator<<(ostream &cout, MyInteger myint);

public:
    MyInteger()
    {
        num = 0;
    }
    // 前置递增
    MyInteger &operator++()
    {
        num++;
        return *this;
    }
    // 后置递增:int代表占位参数，用于区分前置还是后置递增
    // 这里返回的是一个值，因为不能返回局部变量的引用～
    MyInteger operator++(int)
    {
        // 先记录结果，再递增。最后将记录的结果做返回
        MyInteger tmp = *this;
        num++;
        return tmp;
    }

private:
    int num;
};

// 重载左移运算符
ostream &operator<<(ostream &cout, MyInteger myint)
{
    cout << myint.num << endl;
    return cout;
}

void test()
{
    MyInteger myint;
    cout << ++myint << endl;
}

void test2()
{
    MyInteger myint;
    cout << myint++ << endl;
    cout << myint << endl;
}

int main()
{
    // test();
    test2();
    return 1;
}
```

### 赋值运算符重载
>建议这里复习一下深拷贝和浅拷贝

C++编译器至少给一个类添加4个函数
1. 默认构造函数，函数体为空
2. 默认析构函数，函数体为空
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符`operator=`,对属性进行值拷贝
```C++
class Person
{
public:
    int *age;
    Person(int age)
    {
        this->age = new int(age);
    }

    Person& operator=(Person &p)
    {
        if (this->age != NULL)
        {
            delete this->age;
            this->age = nullptr;
        }

        this->age=new int(*p.age);
        return *this;
    }
     //堆区有程序员创建并释放。所以堆区的释放放在析构函数。但这里存在问题：因为这个堆区被delete两次。
    ~Person(){
        if(this->age!=nullptr){
            delete this->age;
            this->age=nullptr;
        }
    }
};

void test()
{
    Person p1(18);
    Person p2(20);
    Person p3(30);
    // // 浅拷贝
    p3=p2= p1;
    cout << *p2.age;
}
int main()
{
    test();
    return 1;
}
```

### 关系运算符重载
作用：重载关系运算符，可以让两个自定义类型对象进行对比操作
```C++


class Person
{
public:
    string name;
    int age;

    Person(string name, int age)
    {
        this->name = name;
        this->age = age;
    }

    bool operator==(Person &p)
    {
        if (p.name == this->name && p.age == this->age)
        {
            return true;
        }
        return false;
    }
};

void test()
{
    Person p1("huang", 22);
    Person p2("huang", 22);
    string res = (p1 == p2) ? "true" : "false";
    cout << res << endl;
    Person p3("wen", 12);
    Person p4("wen12", 12);
    string res2 = (p3 == p4) ? "true" : "false";
    cout << res2 << endl;
}
int main()
{
    test();
    return 1;
}
```

### 函数调用运算符重载
- 函数调用运算符也可以重载
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
- 仿函数没有固定写法，非常灵活
## 继承
有些类之间存在特殊关系，定义类的时候，下级别的成员除了拥有上一级的共性，还有自己的特性。可以使用继承技术，**减少重复代码**。
语法：`class 子类（派生类）：继承方式 父类（基类）`

### 继承方式
一共有三种：
- 公共继承
```C++
class Base1
{
public:
    int a = 10;

protected:
    int b = 10;

private:
    int c = 10;
};
class Son1:public Base1
{
    public:
    void func(){
        a=20;//父类中的公共权限，到子类依然是公共权限
        b=20;//父类中的保护权限，到子类依然是保护权限
        //c=20;//报错，子类访问不到父类私有权限成员
    }
};
void test01()
{
    Son1 s1;
    s1.a=100;
    s2.b=100;//报错。保护权限，类外不能访问
    
}
```
- 保护继承
```C++
class Base2
{
public:
    int a = 10;

protected:
    int b = 10;

private:
    int c = 10;
};

class Son2 : protected Base2
{

public:
    void func() {
        a=20;//父类中的公共权限，到子类依然是保护权限
        b=20;// 父类中的保护权限，到子类依然是保护权限
        //c=20;
    }
};
void test02(){
    Son2 s2;
    s2.a=100;//不可访问
    s2.b=100;//不可访问
}
```
- 私有继承
```C++
class Base3
{
public:
    int a;

protected:
    int b;

private:
    int c;
}

class Son3 : private Base3
{
public:
    void func()
    {
        a = 20; // 父类中的公共权限，到子类依然是私有权限
        b = 20; // 父类中的保护权限，到子类依然是私有权限
        // c=20;
    }
} 

void test03()
{
    Son3 s3;
    //s3.a = 1000; // 变成私有成员，类外访问不到
    //s3.b = 1000; // 变成私有成员，类外访问不到
}

```

### 继承中的对象模型
父类中所有的非静态成员属性都会被子类继承，父类中私有成员属性是被编译器隐藏了，因此是访问不到的，但是确实是被继承下去了


### 继承中构造和析构顺序
子类继承父类后，当创建子类对象，也会调用父类中的构造函数。那么父类和子类的构造和析构顺序谁先谁后？

继承中，先调用父类的构造函数，再调用子类构造函数，析构顺序与构造相反。

### 继承同名成员的处理方式
如果子类与父类出现同名成员，如何通过子类对象，访问到子类或父类中同名的数据呢？
- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域

```C++
class Base
{
public:
    int a = 10;
};

class Son : public Base
{
public:
    int a = 20;
};

void test()
{
    Son s;
    cout<<"Son下的a:"<<s.a<<endl;
    cout<<"Base下的a:"<<s.Base::a<<endl;
}
```
出现同名成员函数，调用方法同上
总结：
1. 子类对象可以直接访问子类中同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中成员函数，加作用域可以访问到父类中的同名函数

### 继承同名静态成员的处理方式
处理方式与上面一致，只是静态访问成员还可以通过类名进行访问

### 多继承
C++允许一个类继承多个类
语法：`class 子类:权限 类1，权限 类2`
现实开发中不建议多继承，当多个父类中含有同名时，记得添加作用域。

### 菱形继承
概念：两个派生类继承同一个基类，又有某个类同时继承两个派生类，这种继承又被称为菱形继承，或者钻石继承
如，羊和驼都继承了动物类，而羊驼继承了羊类和驼类。
```C++
#include <iostream>
using namespace std;

class Animal
{
public:
    int m_age;
};

class Sheep:public Animal{};
class Tuo:public Animal{};

class SheepTuo:public Sheep,public Tuo{};

void test01(){
    SheepTuo st;
    //st.m_age=18;//报错，属于菱形继承，因为两个父类拥有相同数据，需要加作用域区分
    //正确的写法是：
    st.Sheep::m_age=18;
    st.Tuo::m_age=12;

    cout<<"st.Sheep::m_age为:"<<st.Sheep::m_age<<endl;
    cout<<"st.Tuo::m_age为:"<<st.Tuo::m_age<<endl;
}

int main(){
    test01();
}
```

利用**虚继承**解决菱形继承的问题，继承之前，加上关键字` virtual` 变为虚继承。
继承之前，加上关键字virtual变为虚继承
Animal类称为虚基类

```C++
class Animal
{
public:
    int m_age;
};

class Sheep:virtual public Animal{};
class Tuo:virtual public Animal{};

class SheepTuo:public Sheep,public Tuo{};

void test01(){
    SheepTuo st;
    st.m_age=18;//不再报错～
    st.Sheep::m_age=28;
    st.Sheep::m_age=38;

    cout<<"st.m_age为:"<<st.m_age<<endl;//38.相当于共享数据了
}

int main(){
    test01();
}
```
菱形继承导致数据有两份，造成资源浪费

## 多态
### 基本概念
多态是C++面向对象的三大特性之一

多态分为两类：
- 静态多态：函数重载和运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：
- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

**动态多态**的满足条件：
1. 有继承关系
2. 子类重写父类的**虚函数**

动态多态的使用：
父类的指针或者引用指向子类对象

**函数重写**：函数返回值类型、函数名、参数列表完全相同
```C++
class Animal
{
public:
    virtual void speak()
    {
        cout << "动物说话" << endl;
    }
};

class Cat : public Animal
{
public:
    virtual void speak()
    {
        cout << "小猫说话" << endl;
    };
};

void doSpeak(Animal &animal){
    animal.speak();
}
void test() {
    Cat cat;
    doSpeak(cat);
}

int main(){
    test();
    return 1;
}
```

### 纯虚函数和抽象类
在多态中，通常父类中虚函数的实现是毫无意义的，主要是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数的语法:`virtual 返回值类型 函数名(参数列表) = 0;`
**当类中有了纯虚函数，这个类称为抽象类**

抽象类的特点：
- 无法实例化对象
- 子类必须重写抽象类的纯虚函数，否则也属于抽象类


### 虚析构和纯虚析构
多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用子类中的析构代码

解决方式：将父类中的析构函数改为虚析构或者纯虚析构

虚析构和纯虚析构共性：
- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

区别：
- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：
`virtual ~类名(){}`

纯虚析构函数语法：
`virtual ~类名()=0`

```C++
class Animal
{
public:
    virtual void speak() = 0;
    Animal()
    {
        cout << "调用Animal构造函数" << endl;
    }
    //虚析构函数。利用虚析构可以解决父类指针释放子类对象
   // virtual ~Animal()
    //{
      //  cout << "调用Animal析构函数" << endl;
    //}
	//纯虚析构：有了纯虚析构之后，这个类属于抽象类，无法实例化对象
	virtual ~Animal()=0;//会报错，需要在类外实现
};

Animal::~Animal(){
	 cout << "调用Animal纯析构函数" << endl;
}

class Cat : public Animal
{
public:
    Cat(string name)
    {
        cout << "调用cat构造函数" << endl;
        this->name = new string(name);
    }
    void speak()
    {
        cout << *(this->name) << "小猫说话" << endl;
    };

    ~Cat()
    {

        if (this->name != NULL)
        {
            cout << "调用cat析构函数" << endl;
            delete this->name;
            this->name = NULL;
        }
    }

    string *name;
};

void test()
{
    Animal *animal = new Cat("Tom");
    animal->speak();
    //父类指针在析构的时候，不会调用子类中的析构函数，导致子类如果有堆区属性，会出现内存泄漏的问题。解决方式：在父类析构函数之前添加virtual
    delete animal;
}
```

![[Pasted image 20230814214326.png]]

总结：
1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写虚析构或纯虚析构
3. 拥有虚析构函数的类属于抽象类
