# 对称二叉树
>[对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/)
>给你一个二叉树的根节点，检查它是否对称

### 迭代方法
```CPP
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

### 递归方法
```CPP
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```


# 二叉树的最大深度
首先，请区分好二叉树的深度和二叉树的高度
- 二叉树的深度：指从根节点到该节点最长简单路径边的条数或者节点树（从上往下，前序遍历）
- 二叉树的高度：从该节点到叶子结点的最长简单路径边的条数或者节点数（从下往上，后序遍历）

则：**二叉树的最大深度就是根节点的高度**
故可以使用后序遍历来求得最大深度：
```CPP
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);

        int depth = 1+max(left,right);
        return depth;

    }
};
```

当然还可以使用前序遍历：
```CPP
class Solution {
public:
    int result;
    int maxDepth(TreeNode* root) {
        result = 0;
        if(!root) return 0;
        getDepth(root,1);
        return result;
    }

    void getDepth(TreeNode* root,int depth){
        result = depth>result?depth:result;

        // 终止条件
        if(!root->left&&!root->right) return;

        if(root->left){
            depth++;
            getDepth(root->left,depth);
            depth--;
        }

        if(root->right){
            depth++;
            getDepth(root->right,depth);
            depth--;
        }

        return;
    }
};
```

还可以使用层序遍历的方法来计算深度
```CPP
class solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```


# 二叉树的最小深度
这一题和最大深度有一个区别，容易陷入误区：
![[Pasted image 20231024100115.png]]

```CPP
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        int leftNodes = minDepth(root->left);
        int rightNodes = minDepth(root->right);

        if(!root->left&&root->right){
            return 1+rightNodes;
        }
        if(!root->right&&root->left){
            return 1+leftNodes;
        }
        return 1+min(rightNodes,leftNodes);
    }
};
```


# 完全二叉树的节点个数
仍然使用后序遍历：
```CPP
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        int leftNodes = countNodes(root->left);
        int rightNodes = countNodes(root->right);

        return leftNodes+rightNodes+1;
    }
};
```

还可以使用层序遍历的方法，加一个变量，统计节点的数量就可以了
```CPP
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                result++;   // 记录节点数量
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

**以上两种方法没有充分利用完全二叉树的特性**。一棵完全二叉树有两种可能性：要么它是满二叉树，要么是最后一层没有填满

对于第一种情况，很容易计算到节点的个数：$2^h-1$
对于第二种情况，分别递归，得到的子树最后都会是满二叉树：
![[Pasted image 20231024103955.png]]

![[Pasted image 20231024104009.png]]

这里的关键就是如何判断这是一个满二叉树。判断方法就是向左递归的深度等于向右递归的深度。

![[Pasted image 20231024104111.png]]

![[Pasted image 20231024104125.png]]

```CPP
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;

        TreeNode* left = root->left;
        TreeNode* right = root->right;

        int leftDepth = 0;
        int rightDepth = 0;

        while(left){
            left = left->left;
            leftDepth++;
        }

        while(right){
            right = right->right;
            rightDepth++;
        }

        if(leftDepth==rightDepth) return (2<<leftDepth)-1;

        return countNodes(root->left)+countNodes(root->right)+1;
    }
};
```

# 平衡二叉树
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

```CPP
class Solution {
public:
    bool isBalanced(TreeNode* root) {
     return getDepth(root)==-1? false:true;   
    }
    // 左子树 右子树高度差
    int getDepth(TreeNode* node){
        if(node == nullptr) return 0;
        int leftDepth = getDepth(node->left);
        if(leftDepth == -1) return -1;
        int rightDepth = getDepth(node->right);
        if(rightDepth == -1) return -1;
        return abs(leftDepth-rightDepth)>1?-1:1+max(leftDepth,rightDepth);
    }
};
```

# 二叉树的所有路径
![[Pasted image 20231024111948.png]]
```CPP
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if(root == nullptr) return result;
        traversal(path,result,root);
        return result;
    }

    void traversal(vector<int>& path,vector<string>& result,TreeNode* root){
        path.push_back(root->val);//中间
        if(!root->left&&!root->right){
            string res = "";
            for(int i = 0;i<path.size()-1;i++){
                res += to_string(path[i]);
                res+="->";
            }
            res+=to_string(path[path.size()-1]);
            result.push_back(res);
            return;
            
        }
        if(root->left){//左边
            traversal(path,result,root->left);
            path.pop_back();
        }
       if(root->right){//右边
            traversal(path,result,root->right);
            path.pop_back();
       }
    }
};
```

# 左叶子之和
这道题的关键是如何确定这是左叶子节点
```CPP
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right== NULL) return 0;

        int leftValue = sumOfLeftLeaves(root->left);    // 左
        if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况,就一个！！！！
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = leftValue + rightValue;               // 中
        return sum;
    }
};
```
# 找树左下角的值
### 方法一：通过层序遍历找到最后一层，队列里第一个元素（使用一个局部变量保存）
```CPP
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

### 方法二：递归，找到最深层，使用前序遍历、后序遍历
```CPP
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    int findBottomLeftValue(TreeNode* root) {
        if(root==nullptr) return 0;
        traversal(root,0);
        return result;
    }

    void traversal(TreeNode* node,int depth){

        if(node->left==nullptr&&node->right==nullptr){
            if(depth>maxDepth){
                maxDepth = depth;
                result = node->val;
            }
            return;
        }
        if(node->left){
            traversal(node->left,depth+1);
        }
        if(node->right){
            traversal(node->right,depth+1);
        }
    }
};
```
# 路径之和
思路和求路径的那道题一样：
```CPP
class Solution {
private:
    bool traversal(TreeNode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
        if (!cur->left && !cur->right) return false; // 遇到叶子节点直接返回

        if (cur->left) { // 左
            count -= cur->left->val; // 递归，处理节点;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // 回溯，撤销处理结果
        }
        if (cur->right) { // 右
            count -= cur->right->val; // 递归，处理节点;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // 回溯，撤销处理结果
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```
