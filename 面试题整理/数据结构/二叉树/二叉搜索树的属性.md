# 二叉搜索树的搜索
![[Pasted image 20231025095548.png]]
```CPP
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr) return nullptr;
        if(root->val == val) return root;
        if((root->val)<val){
            return searchBST(root->right,val);
        }else{
            return searchBST(root->left,val);
        }
    }
};
```
# 验证二叉搜索树
```CPP
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```
# 二叉搜索树的最小绝对差
既然要求最小的差，那么就要保存上一个节点的值。
```CPP
class Solution {
public:
    int res = INT_MAX;
    TreeNode* pre = nullptr;
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return res;      
    }
    void traversal(TreeNode* node){
        if(node == nullptr) return;
        traversal(node->left);
        if(pre){
            res = min(res,node->val-pre->val);
        }

        pre = node;
        traversal(node->right);
    }
};
```
# 二叉搜索树的众数
```CPP
class Solution {
private:
    int maxCount = 0; // 最大频率
    int count = 0; // 统计频率
    TreeNode* pre = NULL;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;
        searchBST(cur->left);       // 左                                  
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }
        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        pre = NULL; // 记录前一个节点
        result.clear();
        searchBST(root);
        return result;
    }
};
```
# 把二叉搜索树转换为累加树
```CPP
class Solution {
public:
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        if(root == nullptr) return root;
        traversal(root);
        return root;
    }
    void traversal(TreeNode* node){
        if(node == nullptr) return;
        traversal(node->right);
        node->val+=sum;
        sum = node->val;
        traversal(node->left);
    }
};
```

