## 买卖一次
只能买入和卖出一次，找到最佳的买入和卖出时机，以获得最大利润

1. 写出dp数组表达的含义
   - `dp[i][0]`表示 **持有股票所包含的最大利润**
   - `dp[i][1]`表示 不持有股票所包含的最大利润
2. 初始化
   - `dp[i][0]`为-prices[0]
   - `dp[i][1]`为0
3. 递推公式
   当前持有股票的最大利润有两种情况：1) 前一天持有的最大利润 2)当前买入股票 即:`dp[i][0] = max(dp[i-1][0],-prices[i])`
   当前不持有股票的最大利润也有两种情况，1)前一天不持有股票的最大利润 2) 卖出今天的股票 即:`dp[i][1] = max(dp[i-1][0]+prices[i],dp[i-1][1])`

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```
## 买卖多次
可以买卖多次，并得到最大的利润

1. 写出dp数组表达的含义
   - `dp[i][0]`表示 **持有股票所包含的最大利润**
   - `dp[i][1]`表示 不持有股票所包含的最大利润
2. 初始化
   - `dp[i][0]`为-prices[0]
   - `dp[i][1]`为0
3. 递推公式
   当前持有股票的最大利润有两种情况：1) 前一天持有的最大利润 2)昨天不持有股票的所得现金减去 今天的股票价格即:`dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])`
   当前不持有股票的最大利润也有两种情况，1)前一天不持有股票的最大利润 2) 卖出今天的股票 即:`dp[i][1] = max(dp[i-1][0]+prices[i],dp[i-1][1])`

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```
## 限制买卖次数
最多买卖两次，问最大收益

一天一共就有五个状态，

0 没有操作
1 第一次买入
2 第一次卖出
3 第二次买入
4 第二次卖出

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```
## 买卖含有K次交易
方法同上
## 买卖含有冷冻期
可以多次买卖但每次卖出有冷冻期1天

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```
## 买卖有交易费用
和第二题的区别，就是多了一个手续费的操作
```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```