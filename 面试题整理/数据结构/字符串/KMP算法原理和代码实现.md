### KMP有什么用
KMP算法主要用于字符串的匹配上，主要思想是
> 当出现的字符串不匹配时，可以知道一部分之前已经匹配的文本内容，利用这些信息避免从头再去匹配
KMP的重点就是next数组的构建

那么next数组里的数字表示什么？


### 前缀和后缀
前缀是不包含最后一个字符的所有以第一个字符开头的连续子串，后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串

前缀表本质就是next数组，next数组就是相同前后缀的长度
比如，对于模式串：`aabaaf`
![[Pasted image 20231023100519.png]]
长度为前1个字符的子串`a`，最长相同前后缀的长度为0（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）

![[Pasted image 20231023100601.png]]

长度为前2个字符的子串`aa`，最长相同前后缀的长度为1
![[Pasted image 20231023100658.png]]

长度为前3个字符的子串aab，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串aaba，最长相同前后缀的长度为1。 长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。 长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。

最后，得到如下：
![[Pasted image 20231023100649.png]]

再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：
![[KMP精讲2.gif]]

很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？
next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

为什么这么做呢？其实这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。

### 使用next数组来匹配
#### 构建next数组
分为三部：
- 初始化
- 初始化前后缀不相同的情况
- 处理前后缀相同的情况

代码如下：
```CPP
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

