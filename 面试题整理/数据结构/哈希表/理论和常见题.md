# 哈希表
哈希表（散列表）。数组本来就是一张哈希表。哈希表的关键码就是数组的索引下表，然后通过下表直接访问数组中的元素。
![[Pasted image 20231107141336.png]]
哈希表解决什么问题？

一般哈希表就是用来快速判断一个元素是否出现在集合里。

## 哈希函数
哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速指导这位同学是否在这所学校里了
![[Pasted image 20231107142431.png]]
## 哈希碰撞

映射到同一个索引下标的位置，这一现象称为哈希碰撞
![[Pasted image 20231107143041.png]]
解决哈希碰撞有两种解决方法，拉链法和线性探测法。
## 拉链法

发生冲突的元素都存储在链表中
![[Pasted image 20231107143505.png]]

## 线性探测法

冲突就找下一个空位放置
![[Pasted image 20231107143723.png]]
## 常见的三种哈希结构

我们想使用哈希法解决问题的时候，一般会选择如下三种数据结构

- 数组
- set
- map

在c++中，set和map分别提供以下三种数据结构：
![[Pasted image 20231107150113.png]]

![[Pasted image 20231107150139.png]]
### 常见题

#### 有效的字母异位词
异位词：字符串中的每个字符出现次数一样
```CPP
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```

#### 四数相加
![[Pasted image 20231212133913.png]]

```C++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
          unordered_map<int,int> map;
          int count = 0;//符合要求的元组个数
          for(int a:nums1){
              for(int b:nums2){
                  map[a+b]++;
              }
          }

          for(int c :nums3){
              for(int d:nums4){
                if(map.find(0-(c+d))!=map.end()){
                    count+=map[0-(c+d)];
                }
              }
          } 

          return count; 
    }
};
```

#### 三数之和

双指针法
```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;

        sort(nums.begin(),nums.end());

        for(int i = 0;i<nums.size();i++){
            if(nums[i]>0) return result;

            if(i>0&&nums[i] == nums[i-1]) continue;

            int left = i+1;
            int right = nums.size()-1;

            while(left<right){
                if(nums[left]+nums[right]+nums[i]>0){
                    right--;
                }else if(nums[left]+nums[right]+nums[i]<0){
                    left++;
                }else{
                     result.push_back(vector<int>{nums[i],nums[left],nums[right]});
                     while(left<right&&nums[right] == nums[right-1]) right--;
                     while(left<right&&nums[left] == nums[left+1]) left++;
                     right--;
                     left++;   
                } 
            }
        }

        return result;
    }
};
```

#### 四数之和
```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;

        sort(nums.begin(),nums.end());

        for(int i = 0;i<nums.size();i++){
            if(nums[i]>target&&nums[i]>=0) return result;
            
            if(i>0&&nums[i] == nums[i-1]){continue;}
            for(int j = i+1;j<nums.size();j++){
                if(nums[i]+nums[j]>target&&nums[i]+nums[j]>=0){break;}
                if(j>i+1&&nums[j] == nums[j-1]) continue;
                int left = j+1;
                int right = nums.size()-1;

                while(left<right){
                    if((long)nums[i]+nums[j]+nums[left]+nums[right]>target){
                        right--;
                    }else if((long)nums[i]+nums[j]+nums[left]+nums[right]<target){
                        left++;
                    }else{
                        result.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        while(left<right&&nums[left] == nums[left+1]){left++;}
                        while(left<right&&nums[right] == nums[right-1]){right--;}

                        left++;
                        right--;
                    }
                }
            }
        }

        return result;
    }
};
```
