# UDP协议
`UDP` 是User Datagram Protocol的简称， 中文名是**用户数据报协议**，是一种*无连接、不可靠*的协议，它只是简单地实现从一端主机到另一端主机的数据传输功能，这些数据通过IP层发送，在网络中传输，到达目标主机的顺序是无法预知的，因此需要应用程序对这些数据进行排序处理，这就带来了很大的不方便，此外，UDP协议更没有流量控制、拥塞控制等功能，在发送的一端，UDP只是把上层应用的数据封装到UDP报文中，在差错检测方面，仅仅是对数据进行了简单的校验，然后将其封装到IP数据报中发送出去。而在接收端，无论是否收到数据，它都不会产生一个应答发送给源主机，并且如果接收到数据发送校验错误，那么接收端就会丢弃该UDP报文，也不会告诉源主机，这样子传输的数据是无法保障其准确性的，如果想要其准确性，那么就需要应用程序来保障了。

UDP协议的特点：
1. 无连接、不可靠。
2. 尽可能提供交付数据服务，出现差错直接丢弃，无反馈。
3. 面向报文，发送方的UDP拿到上层数据直接添加个UDP首部，然后进行校验后就递交给IP层，而接收的一方在接收到UDP报文后简单进行校验，然后直接去除数据递交给上层应用。
4. 支持一对一，一对多，多对一，多对多的交互通信。
5. 速度快，UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快，即使在网络拥塞的时候UDP也不会降低发送的数据。

![[Pasted image 20231108165510.png]]

UDP虽然有很多缺点，但是也不排除其能用于很多场合，因为在如今的网络环境下，UDP协议传输出现错误的概率是很小的，并且它的实时性是非常好，常用于实时视频的传输，比如直播、网络电话等，因为即使是出现了数据丢失的情况，导致视频卡帧，这也不是什么大不了的事情，所以，UDP协议还是会被应用与对传输速度有要求，并且可以容忍出现差错的数据传输中。

# TCP协议
### TCP协议简介
TCP与UDP一样，都是传输层的协议，但是提供的服务却大不相同，UDP为上层应用提供的是一种不可靠的，无连接的服务，而TCP则提供一种面向连接、可靠的字节流传输服务，TCP让两个主机建立连接的关系，应用数据以数据流的形式进行传输，这与UDP协议是不一样：

- UDP运载的数据是以报文的形式，各个报文在网络中互不相干传输，UDP每收到一个报文就递交给上层应用，因此如果对于大量数据来说，应用层的重装是非常麻烦的，因为UDP报文在网络中到达目标主机的顺序是不一样的；
- 而TCP采用数据流的形式传输，先后发出的数据在网络中虽然也是互不相干的传输，但是这些数据本身携带的信息却是紧密联系的，TCP协议会给每个传输的字节进行编号，当然啦，两个主机方向上的数据编号是彼此独立的，在传输的过程中，发送方把数据的起始编号与长度放在TCP报文中，在接收方将所有数据按照编号组装起来，然后返回一个确认，当所有数据接收完成后才将数据递交到应用层中。


#### TCP与UDP的区别
![[Pasted image 20231108170522.png]]

### TCP首部
![[Pasted image 20231107163947.png]]

- TCP端口号
TCP连接需要四个要素确定唯一一个连接：(源IP,源端口号)+(目标IP,目标端口号)
所以TCP
首部预留两个16为作为端口号存储，而IP地址由上一层IP协议负责传递
端口的范围为$2^{16}=65535$
另外1024以下是系统保留的，1024-65535是用户使用的端口范围

- TCP的确认号和序号
**32位序号seq**：tcp通信过程中某一传输方向上的字节流的字节的序号，通过这个来确认发送的数据有序。
**32位确认号ack**：TCP对上一次seq序号作出的确认号，用来响应TCP报文段，给收到的TCP报文段序号seq加1

![[Pasted image 20231107164525.png]]

#### TCP三次握手建立连接
首先建立连接的过程由客户端发起，而服务器无时无刻都在等待客户端的链接过程如下：
![[Pasted image 20231107164719.png]]

![[Pasted image 20231107164700.png]]
#### 为什么要三次握手？
1. 当旧的的SYN报文段先到达服务器，服务器法就会一个ACK+SYN报文段。客户端收到后就可以根据自身的上下文，判断这是一个历史连接，那么客户端就会发送RST报文段给服务端，请求终止连接，如果是两次握手收到服务端的响应后开始发送数据，不能判断当前连接是否为历史连接，三次握手可以在客户端准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接

2. TCP通信双方，都必须维护一个序列号，序列号是一个可靠传输的一个关键因素。两次握手只能保证一方的初始序列号能被对方接受，没办法保证双方的初始序列号都能被确认接收

3. 当客户端向服务端发起连接请求报文段没有丢失，而是在某个网络节点滞留，以致于到了该连接释放以后才到达服务端。本来是一个早已失效的报文段，但server收到后以为是客户端再次发起的新请求，于是就向客户端发起确认报文段， 同意建立连接。假设不采用三次握手，那么server确认后，新连接就建立了。由于client没有建立连接的请求，就不会理睬server的确认，也不会向server发送数据。但server一直等待client发送数据，这就造成server资源的浪费
#### TCP断开连接

![[Pasted image 20231107173311.png]]

#### 为什么要等待2MSL时间？
MSL是指 报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。主要有两个原因：

1. 由于IP协议的不可靠性或是其他原因，导致server端没有收到client端的ACK报文段，那么server就会重新发送FIN报文段，如果此时client的连接已经处于close的状态，那么重发的FIN报文段就找不到对应的连接，就导致错乱了。
2. 如果关闭后的client重新发起连接，并且新连接与刚关闭的连接的端口号是相同的，并且之前就连接的某些数据滞留在网络中，这些延迟数据在建立新连接后到达客户端后，TCP以为这些数据是属于新连接的，导致数据包混乱。
3. 为什么是两倍，是因为网络中可能存在发送方的数据包，这些发送方的数据包被接收方处理后又会向对方发送响应，以来就要等待两倍时间

#### 为什么要四次挥手
关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会中断这次TCP连接。

#### TCP状态
TCP协议根据连接时接收到报文的不同类型，采取相应动作也不同，还要处理各个状态的关系，如当收到握手报文时候、超时的时候、用户主动关闭的时候等都需要不一样的状态去采取不一样的处理。

TCP协议的状态如下：

- LISTENING状态：提供某种服务，侦听远方TCP端口的连接请求，当提供的服务没有被连接时，处于LISTENING状态，端口是开放的，等待被连接。

- SYN_SENT (客户端状态)：客户端调用connect()函数，将会发送一个SYN请求建立一个连接，在发送连接请求后等待匹配的连接请求，此时状态为SYN_SENT.

- SYN_RECEIVED (服务端状态)：在收到和发送一个连接请求后，等待对方对连接请求的确认，当服务器收到客户端发送的同步信号时，将标志位ACK和SYN置1发送给客户端，此时服务器端处于SYN_RCVD状态，如果连接成功了就变为ESTABLISHED，正常情况下SYN_RCVD状态非常短暂。

- ESTABLISHED状态：这个状态是处于稳定连接状态，建立连接的TCP协议两端的主机都是处于这个状态，它们相互知道彼此的窗口大小、序列号、最大报文段等信息。

- FIN_WAIT_1与FIN_WAIT_2状态：处于这个状态一般都是单向请求终止连接，然后主机等待对方的回应，而如果对方产生应答，则主机状态转移为FIN_WAIT_2，此时{主机->对方}方向上的TCP连接就断开，但是{对方->主机}方向上的连接还是存在的。此处有一个注意的地方：如果主机处于FIN_WAIT_2状态，说明主机已经发出了FIN报文段，并且对方也已对它进行确认，除非主机是在实行半关闭状态，否则将等待对方主机的应用层处理关闭连接，因为对方已经意识到它已收到FIN报文段，它需要主机发一个 FIN 来关闭{对方->主机}方向上的连接。只有当另一端的进程完成这个关闭，主机这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。否则这意味着主机这端可能永远保持这个FIN_WAIT_2状态，另一端的主机也将处于 CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。

- CLOSE-WAIT状态：等待从本地用户发来的连接中断请求 ，被动关闭端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并进入CLOSE_WAIT.

- TIME_WAIT状态：TIME_WAIT状态也称为 2MSL等待状态。每个具体TCP连接的实现必须选择一个TCP报文段最大生存时间MSL（Maximum Segment Lifetime），如IP数据报中的TTL字段，表示报文在网络中生存的时间，它是任何报文段被丢弃前在网络内的最长时间，这个时间是有限的，为什么需要等待呢？我们知道IP数据报是不可靠的，而TCP报文段是封装在IP数据报中，TCP协议必须保证发出的ACK报文段是正确被对方接收， 因此处于该状态的主机必须在这个状态停留最长时间为2倍的MSL，以防最后这个ACK丢失，因为TCP协议必须保证数据能准确送达目的地。

讲了那么多理论，下面就结合图文来详解一下TCP协议在建立连接与终止连接的时候所有的状态转移处理是怎么样的，具体见：
![[Pasted image 20231026171051.png]]

### 复杂的TCP
![[Pasted image 20231108143722.png]]

#### 为什么TCP需要流量控制
   TCP三次握手，发送端和接收端进入到ESTABLISHED状态，它们即可以愉快地传输数据啦。  

   但是发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦  

   TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是流量控制

作者：小熊学Java
链接：https://www.nowcoder.com/discuss/406776190017585152
来源：牛客网
#### 重传机制
1. 超时重传
设定一个定时器，当超过指定时间后，没有收到对方的确认ACK应答报文，就会重发该数据

超时重传的情况有两种：
![[Pasted image 20231108144243.png]]

RTT:往返时延，数据从网络一段传到另一端所需的时间

![[Pasted image 20231108144433.png]]

![[Pasted image 20231108144710.png]]
![[Pasted image 20231108144749.png]]

RTO的计算方式
![[Pasted image 20231108144804.png]]

2. 快速重传
以数据驱动重传
![[Pasted image 20231108145757.png]]

3. SACK(选择性确认)
为了解决重传哪些报文的问题而提出。

这种方式是在TCP头部『选项』字段里面加一个SACK的东西，他可以将缓存的地图发送给发送方，这样发送方就可以知道那些数据收到了，哪些数据没有受到，知道了这些信息，就可以只重传丢失的数据

![[Pasted image 20231108150342.png]]

4. D-SACK(Duplicate SACK)
主要使用了SACK来告诉『发送方』有哪些数据被重复接收了
![[Pasted image 20231108151133.png]]

![[Pasted image 20231108151147.png]]

#### 滑动窗口
1. 什么是窗口
TCP每发送一个数据，就需要一次应答，然后继续发送。如果数据往返时间越长，网络吞吐量越低

窗口实现就是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
![[Pasted image 20231108160130.png]]

图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅收到了 ACK
700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答。

2. 什么决定窗口大小
TCP的首部有一个字段 叫做窗口大小

这个字段是接收端告诉发送酸自己还有所少缓冲区可以接受数据，发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来

通常窗口的大小是由接受方的窗口大小来决定的

3. 发送方的滑动窗口

![[Pasted image 20231108162001.png]]

![[Pasted image 20231108162040.png]]
数据全都发送以后，可⽤窗⼜⼤⼩为0，在没收到ACK确认应答之前⽆法继续发送数据。
![[Pasted image 20231108162053.png]]
在收到32-36的ACK应答后，如果窗⼜⼤⼩不变，则滑动窗⼜先后移动5个字节，那么52-56变成可⽤窗⼜，可以继续
发送数据。

![[Pasted image 20231108162232.png]]

5. 接收方滑动窗口
![[Pasted image 20231108162539.png]]

#### 拥塞控制
拥塞控制通过拥塞窗⼜来防⽌过多的数据注⼊⽹络，使得⽹络中的路由器或者链路过载。

![[Pasted image 20231108163530.png]]

常见的拥塞控制算法：
1. 慢启动
2. 拥塞避免
3. 拥塞发生
4. 快速恢复

1. 慢启动
慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼜ cwnd 的⼤⼩就会加 
有⼀个慢启动门限ssthresh状态变量：
1. 当 cwnd < ssthresh 时，使⽤慢启动算法。
2. 当 cwnd >= ssthresh 时，就会使⽤拥塞避免算法。

2. 拥塞避免
