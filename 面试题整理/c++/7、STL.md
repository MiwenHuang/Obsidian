C++ STL从广义来讲了三类：算法、容器和迭代器
- 算法包括排序，复制等常用算法，以及不同容器特定的短发
- 容器就是数据的存放形式，包括序列式容器和关联式容器
- 迭代器就是不暴露容器内部情况下对容器的遍历
### STL中的hashtable的实现？
STL中的hashtable使用的是开链法解决hash冲突问题
![[Pasted image 20240326112005.png]]
hahstable中的bucket所维护的list，这个list是由hashtable_node数据结构所组成的linked-list，而bucket本身使用vector进行存储，在设计bucket数据上，内置了28个质数，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量，其中每个bucket所维护的长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。

#### hashtable中解决冲突有哪些方法？
1. 线性探测
   使用hash函数计算出的位置如果已经有元素占有，则向后一次寻找，到了表尾则回到表头，直到找到一个空位
2. 开链
   每个链表维护一个list。如果使用hash函数计算出的值相同，则按顺序存在这个list中
3. 散列
   发生冲突时在使用另一个hash函数计算出一个地址，知道不冲突
4. 二次探测
   使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$...的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测

### STL的两级空间配置器
#### 为什么需要两级空间配置器
首先 我们知道动态开辟内存时，要在堆上频繁开辟内存，就会在堆上产生很多外部碎片，浪费了内存空间，随着外部碎片的增多，内存分配起就找不到合适内存情况下合并空闲块，浪费时间，降低了效率

当开辟内存小于等于128字节时，则视为开辟小块内存，则调用二级空间配置器。


#### 一级配置器
一级空间配置器中重要的函数就是allocate、deallocate、reallocate。一级配置器是以malloc、free、realloc等函数执行实际的内存配置

![[Pasted image 20240326133038.png]]

#### 二级配置器
![[Pasted image 20240326133106.png]]
二级配置器维护了16条链表，分别表示0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，传入一个字节参数，表示需要多大的内存，会自动帮你校对到第几号链表，在找到链表后查看链表是否为空，如果不为空直接从对应的free_list拔出，将已经拨出的指针向后移动一位

如果free_list为空，先看其内存池是不是空，如果内存池不为空：
1. 先检验它剩余空间是否够20个节点，若足够则直接从内存池拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次有相同大小的内存需求时，可直接拨出
2. 如果不够20个节点大小，则看它能否满足一个节点大小，如果够的话直接拿出一个分配给用户，然后从剩余的空间中分配可能多的节点挂在相应的free_list中
3. 如果一个节点内存都不能满足的话，则将内存池中剩余空间挂在相应的free_list当中，然后再给内存池申请内存。

当内存池为空时，申请内存，此时二级空间配置器会使用malloc从堆上申请内存，申请内存块40个，一半拿来用一半放进内存池中

如果malloca没有成功，说明堆上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。

### vector与list的区别
#### 区别
- vector的随机访问效率高，但在插入和删除时挪动数据，不易操作
- list的访问需要遍历整个链表，他的随机访问效率低。但对数据的插入和删除操作等比较方便，改变指针的指向即可
- 从遍历上来说，list是单向的，vector是双向的
- vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用

### vector的 size和capacity
size()函数返回的是已用空间大小，capacity()返回的是总空间大小。如果capacity()与size()相等，那么vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长

由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n>capacity()时，调用reserve(n)才会改变vector容量。

### 容器内部删除一个元素
1. 序列式容器
erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器
`It = c.erase(it);`
2. 关联容器
erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；
`c.erase(it++);`

### map和set是怎么实现的
他们底层都是使用红黑树的结构实现，因此插入、删除等操作都在O(logn)时间内完成，因此可以高效的插入删除

### STL中list与queue之间的区别
1. list是一个双向链表，而且还是一个环状双向链表，所以需要一个指针
2. list不再能够像vector一样以普通指针作为迭代器，因为其节点不保存在存储空间中连续存在
3. list不像vector那样有可能在空间不足时重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后仍然有效
4. deque是一种双向开口的连续线性空间，可以在头尾两端分别做元素的插入和删除操作
5. deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作；二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。
### 常见容器性质总结？
1. vector 底层数据结构为数组 ，支持快速随机访问
2. list 底层数据结构为双向链表，支持快速增删
3. deque 支持首尾（中间不能）快速增删，也支持随机访问
deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.
4. stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
5. queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）
6. priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
7. set 底层数据结构为红黑树，有序，不重复
8. multiset 底层数据结构为红黑树，有序，可重复
9. map 底层数据结构为红黑树，有序，不重复
10. multimap 底层数据结构为红黑树，有序，可重复
11. unordered_set 底层数据结构为hash表，无序，不重复
12. unordered_multiset 底层数据结构为hash表，无序，可重复
13. unordered_map 底层数据结构为hash表，无序，不重复
14. unordered_multimap 底层数据结构为hash表，无序，可重复

### set和map的区别，multimap和multiset的区别
#### set和map的区别
set只提供一种数据类型的接口，set的value和key都是一样的
map提供两种数据类型的接口，保存的是两份元素

#### multimap和map的区别
multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。


#### 红黑树概念
1. 属于二叉排序树
2. 所有节点非黑即红，并且根节点必为黑节点，红节点的子节点必为黑，从根节点到null的任何路径上黑节点数相同

### STL中unordered_map和map的区别和应用场景
map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息

unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大

从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景

