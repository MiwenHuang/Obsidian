指针实质就是一个变量，只不过这个变量里面存储的是内存地址

### 1. 函数指针和指针函数
#### 函数指针
首先是一个指针，这个指针指向函数
实例：
```C++
int max(int x,int y)
{
    int z;
    if (x > y)
    {
        z=x;
    }
    else
    {
        z=y;
    }
    return z;
}
int main()
{
    int (*p) (int ,int );//定义一个函数指针
    int a,b,c;
    p=max;//把函数的地址给指针
    a=20;
    b=30;
    c=(*p)(a,b);//调用函数指针
    printf("%d\n",c);
    return 0;
}

```

#### 指针函数
首先是个函数，这个函数的返回值是个指针类型
例如：
`int* fun(int x,int y){}`

### 3. 指针运算
```CPP
#include<stdio.h> 
int main() 
{ 
char a[20]="You_are_a_girl"; 
char *p=a; char **ptr=&p; 
printf("**ptr=%c\n",**ptr); 
ptr++; 
printf("**ptr=%c\n",**ptr); 
}

```

在这个例子中是无法确定二级指针++之后指向的地址内容，因为 **二级指针(ptr)指针指向的一级指针的地址** ，如果二级指针(ptr)++之后，那么就会指向一级指针的后4个字节(对于32位操作系统来说指针类型是4字节)，至于这个地址里面是啥无从得知

#### 指针运算自加
![[Pasted image 20231011172010.png]]

### 4. 指针数组和数组指针
#### 指针数组
是个数组，这个数组的元素是指针
```CPP
int *p [4];
int a[4]={1,2,3,4};
p[0]=&a[0];
printf("%d\n",*p[0]);

```

#### 数组指针
是个指针，但是这个指针指向数组
如:`int (*p)[4]`表示一个指向有4个`int`元素的数组的指针，`p+1`加的是4个`int`
```CPP
int num[8] = {1,2,3,4,5,6,7,8};
int (*p)[4];
p = num;
```

### 5. 指针与数组的区别
1. 概念
   数组：是同种类型的集合
   指针：保存的地址的值
2. 赋值
   同种类型指针之间可以直接复制，数组只能一个个赋值
3. 存储
   数组是连续的一段空间，指针的存储空间是不确定
4. 修改内容不同
   `char* p[] = "hello"`执行`p[0]='s'是错误的，因为p是指针，指向字符串常量`.`char p[] = "hello"`,`p[0]='s'`是可以的因为p是数组
4. 所占字节不同
   指针在32位系统中是4个字节，而数组是不固定的，要看数组的类型和元素的个数

### 6. 野指针？如何产生？如何避免
野指针是指 指针指向的地址是不确定的
产生的原因：释放内存后，指针没有及时置空
如何避免：
1. 初始化指针，置`NULL`
2. 申请内存后判空
3. 指针释放后置`NULL`
4. 使用智能指针

如：
```CPP
int* p = NULL;
p1 = (int*)calloc(n,sizeof(int));
assert(p!=NULL);
free(p1);
p1=NULL;
```


### 数组名num / &num /&num[0]的区别
首先，都是数组的首地址，但是表示的类型不一样
1. &num[0]是int\*类型，含义是取第一个元素的地址
2. num是int[5]类型，是数组类型；
3. &num是int*[5]类型，是数组指针

类型不同，偏移的计算方法
对于一维数组来说
num+1是偏移到下个元素，&num+1是偏移整个数组

对于二维数组来说
num+1是偏移一个一维数组，&num+1是整个数组

64位系统：
`int num[100];`
`sizeof(num)`//400
`sizeof(&num);`//8
`sizeof(&num[0])`//8

#### 数组作为参数传递
```CPP
#include <stdio.h>
//数组名作为参数传递时，实际上是变为指针，所以，sizeof（arr）是指针的大小
void print_array(int arr[]) {
    int n = sizeof(arr) / sizeof(arr[0]);
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);// 1 2
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
 
    print_array(arr);
    return 0;
}

```
### 有了指针为什么还需要引用
直接原因是为了支持运算符的重载

用指针的容易出错：
1. 操作空指针
2. 使用野指针
3. 不知不觉改变了指针的值

引用区别于指针的特性：
1. 引用必须初始化
2. 一个引用永远指向他初始化的对象

#### 使用指针的好处
1. 指针可以动态分配内存
2. 在链表中可以方便修改链表的节点
3. 解析字符串
4. 相同类型的指针可以直接复制

#### 指针和引用的区别
- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只有一级
- 指针可以为空，引用不能为NULL且在定义时必须初始化
- 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
- sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针

### 在传递函数参数时，什么时候使用指针，什么时候使用引用呢
- 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完记得释放内存不然会造成内存泄漏。而使用局部变量的引用是没有意义的
- 对栈空间比较敏感的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
- 类对象作为参数传递时候使用引用

### 指针常量、常量指针、指向常量的常量指针
#### 常量指针
`const int* p` 指针指向的地址的内容不可以改变，但是指向可以改变

#### 指针常量
`int* const p` 指针指向的地址不可以改变，但是可以改变内容

#### 指向常量的常量指针
`const int* const p` 都不可以改变


