### 1. 内存分配的方式
1.	栈上分配：
在执行函数之前，函数内部的局部变量都可以在栈上创建，函数执行完毕之后会自动释放
2.	静态全局存储区
全局变量和静态变量
3.	堆上分配
由程序员分配，好比new，delete free，malloc 

### 2. 堆和栈有什么区别
1.申请方式不同：
栈是由操作系统自由分配和释放，堆是由程序员手动申请释放
2.申请大小的限制：
栈是向低地址申请的空间，一块连续的内存，也就是说，栈的大小和地址是由系统预先规定好的，如果申请的空间超过栈的剩余空间就会提示overflow
堆的申请是向高地址扩张的，是不连续的内存区域，这是由于系统使用链表来存储的空闲内存地址
3.申请的效率
栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些

#### 堆栈溢出一般是由什么原因导致的
1.**函数调用层次太深**。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。
2.**动态申请空间使用之后没有释放**。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不当造成堆溢出。
3.**数组访问越界**。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。
4.**指针非法访问**。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。

### 3. c++的内存管理是怎样的
在c++中虚拟内存分为代码段、数据段、bss段、堆、共享区、栈
**代码段**:包括只读存储去和文本区，其中只读存储区字符串常量，文本区存储程序的机械代码
**数据段**：全局变量、静态变量（全局、局部）
BSS段：未初始化的全局变量和静态变量（全局、局部），以及所有被初始化为0的全局变量和静态变量
**堆**:调用new/malloc申请的内存空间，地址由低地址向高地址扩张
**映射区**：存储动态链接库以及调用mmap函数的文件映射
**栈**：局部变量、函数的返回值，函数的参数，地址由高地址向低地址扩张

### 4. 内存泄漏
![[Pasted image 20231007093340.png]]
#### 什么是内存泄漏
内存泄漏（Memory Leak）是指在程序运行过程中，程序分配的内存空间没有被正确释放，导致这些内存空间变得不可访问且不可用，从而浪费了系统的内存资源。
内存泄漏通常是由于程序员未正确管理动态分配的内存而引起的。

内存泄漏通常发生在以下情况下：

- 忘记释放动态分配的内存：使用 new、malloc、calloc 等动态分配内存后，需要使用 delete、free 等来释放这些内存，但有时程序员会忘记这么做。
- 丢失指向动态分配内存的指针：如果程序中的指针变量丢失了指向动态分配内存的引用，那么将无法释放这些内存，导致内存泄漏。
- 循环引用：在某些情况下，例如在使用智能指针时，循环引用可能导致内存泄漏，因为对象之间的引用计数永远不会达到零，从而导致内存无法释放。

#### 如何减少内存泄漏
1.良好的编码习惯，使用内存分配的函数，一但使用完毕之后就要记得使用对应的函数释放掉
2.将分配的内存的指针以链表的形式自行管理，使用之后从链表中删除，程序结束时可以检查链表
3.使用智能指针
4.使用常见插件，ccmalloc

### 5. 字节对齐问题
#### 什么是字节对齐
字节对齐（Byte Alignment）是指在计算机中存储数据时，为了提高访问速度和硬件的效率，要求数据结构从特定的地址开始存放，并且按照某种规定的字节长度的整数倍对齐存放。

#### 为什么需要字节对齐
需要字节对齐的根本原因在于CPU访问数据的效率问题
比如：
![[Pasted image 20231007095147.png]]

### 6. `malloc`、`calloc`、`realloc`内存申请函数
在C和C++中，有几个常用的函数可用于动态分配内存，以便在运行时创建和管理内存块。这些函数包括 `malloc`、`calloc` 和 `realloc`。以下是它们的介绍和使用方法：

1. **malloc**（Memory Allocation）：
   - `malloc` 函数用于分配指定大小的内存块，并返回指向该内存块的指针。
   - 它接受一个参数，即要分配的字节数，返回一个 `void*` 类型的指针。
   - 分配的内存块的内容不会被初始化，它们可以包含任何值。
   - 如果分配失败，`malloc` 返回 `NULL`。

   示例：
   ```c
   int* arr = (int*)malloc(5 * sizeof(int));
   if (arr != NULL) {
       // 成功分配内存
       // 使用arr来操作分配的内存
       free(arr); // 释放内存
   } else {
       // 分配失败
   }
   ```

2. **calloc**（Contiguous Allocation）：
   - `calloc` 函数用于分配指定数量和大小的连续内存块，并返回指向该内存块的指针。
   - 它接受两个参数，即要分配的元素数量和每个元素的字节数，返回一个 `void*` 类型的指针。
   - 分配的内存块会被初始化为零。
   - 如果分配失败，`calloc` 返回 `NULL`。

   示例：
   ```c
   int* arr = (int*)calloc(5, sizeof(int));
   if (arr != NULL) {
       // 成功分配内存，并且内存已被初始化为0
       // 使用arr来操作分配的内存
       free(arr); // 释放内存
   } else {
       // 分配失败
   }
   ```

3. **realloc**（Reallocate Memory）：
   - `realloc` 函数用于重新分配已分配内存的大小。
   - 它接受两个参数，即原始内存块的指针和新的字节数，返回一个指向重新分配内存块的指针。
   - `realloc` 还可以用于将一个已分配的内存块扩展或缩小到新的大小。
   - 如果分配失败，`realloc` 返回 `NULL`。如果分配成功，原始内存块会被释放。

   示例：
   ```c
   int* arr = (int*)malloc(5 * sizeof(int));
   if (arr != NULL) {
       // 成功分配内存
       // 使用arr来操作分配的内存

       // 重新分配内存大小为10个int
       int* new_arr = (int*)realloc(arr, 10 * sizeof(int));
       if (new_arr != NULL) {
           // 重新分配成功
           arr = new_arr; // 更新指针
       } else {
           // 重新分配失败，但原始内存仍然有效
       }

       free(arr); // 释放内存
   } else {
       // 分配失败
   }
   ```

请注意，使用这些函数分配内存后，必须使用 `free` 函数来释放内存，以防止内存泄漏。

### 7、智能指针
智能指针就是帮程序员管理动态分配的内存，自动释放new出来的内存，从而避免内存泄漏。

#### auto_ptr
auto_ptr 是c++ 98定义的智能指针模板，其定义了管理指针的对象，可以将new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存！

使用：
```C++
#include<iostream>
#include<memory>
using namespace std;
class Test {
public:
	Test() { cout << "Test的构造函数..." << endl; }
	~Test() { cout << "Test的析构函数..." << endl; }

	int getDebug() { return this->debug; }

private:
	int debug = 20;
};

int main(){
   //Test *test = new Test;
	auto_ptr<Test> test(new Test);
	cout << "test->debug：" << test->getDebug() << endl;
	cout << "(*test).debug：" << (*test).getDebug() << endl;
	return 0;
}
```

自动调用了析构函数：

![[Pasted image 20231206184104.png]]

##### 常用的三个函数
1. get 获取智能指针托管的指针地址
```C++
// 定义智能指针
auto_ptr<Test> test(new Test);

Test *tmp = test.get();		// 获取指针返回
cout << "tmp->debug：" << tmp->getDebug() << endl;
```

2. release 取消智能指针对动态内存的托管
```C++
// 定义智能指针
auto_ptr<Test> test(new Test);
Test *tmp2 = test.release();	// 取消智能指针对动态内存的托管
delete tmp2;	// 之前分配的内存需要自己手动释放
```

3. reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉
```C++
// 定义智能指针
auto_ptr<Test> test(new Test);

test.reset();			// 释放掉智能指针托管的指针内存，并将其置NULL

test.reset(new Test());	// 释放掉智能指针托管的指针内存，并将参数指针取代之
```

##### 使用建议：
1. 尽可能不要将auto_ptr 变量定义为全局变量或指针
   ```C++
   // 没有意义，全局变量也是一样
auto_ptr<Test> *tp = new auto_ptr<Test>(new Test);	
```
2. 不要把auto_ptr 智能指针赋值给同类型的另外一个 智能指针；
   ```C++
   auto_ptr<Test> t1(new Test);
auto_ptr<Test> t2(new Test);
t1 = t2;	// 不要这样操作...
```

##### auto_ptr被抛弃，被unique_ptr替代
1. 复制或者赋值都会改变资源的所有权
```C++
// auto_ptr 被C++11抛弃的主要原因
auto_ptr<string> p1(new string("I'm Li Ming!"));
auto_ptr<string> p2(new string("I'm age 22."));

cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;

// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，
// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。
p1 = p2;	
cout << "p1 = p2 赋值后：" << endl;
cout << "p1：" << p1.get() << endl;
cout << "p2：" << p2.get() << endl;
```
![[Pasted image 20231206185325.png]]
2. 在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值
```C++
vector<auto_ptr<string>> vec;
auto_ptr<string> p3(new string("I'm P3"));
auto_ptr<string> p4(new string("I'm P4"));

// 必须使用std::move修饰成右值，才可以进行插入容器中
vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

cout << "vec.at(0)：" <<  *vec.at(0) << endl;
cout << "vec[1]：" <<  *vec[1] << endl;


// 风险来了：
vec[0] = vec[1];	// 如果进行赋值，问题又回到了上面一个问题中。
cout << "vec.at(0)：" << *vec.at(0) << endl;
cout << "vec[1]：" << *vec[1] << endl;
```
访问越界了
![[Pasted image 20231206185929.png]]

3. 不支持对象数组的内存管理
```C++
auto_ptr<int[]> array(new int[5]);	// 不能这样定义
```

链接：
[智能指针](https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/)
