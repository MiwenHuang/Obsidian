### 类的对象存储空间
- 非静态成员的数据类型大小之和
- 编译器加入的额外成员变量，比如只想虚函数表的指针

C++种空类的size为1，作为基类的时候size为0

### 堆和栈有什么区别
1. 申请方式不同：
栈是由操作系统自由分配和释放，堆是由程序员手动申请释放
2. 申请大小的限制：
栈是向低地址申请的空间，一块连续的内存，也就是说，栈的大小和地址是由系统预先规定好的，如果申请的空间超过栈的剩余空间就会提示overflow
堆的申请是向高地址扩张的，是不连续的内存区域，这是由于系统使用链表来存储的空闲内存地址
3. 申请的效率
栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些

### 堆和栈哪一个更快
毫无疑问是栈快一点。

因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

#### 堆栈溢出一般是由什么原因导致的
1.**函数调用层次太深**。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。
2.**动态申请空间使用之后没有释放**。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不当造成堆溢出。
3.**数组访问越界**。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。
4.**指针非法访问**。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。

### c++的内存管理是怎样的
C++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区
![[Pasted image 20240326095909.png]]
**栈**：在执行函数，函数内的局部变量的存储单元都在栈上创建，函数结束时，这些存储单元自动释放。
**堆**：由new分配的内存块，他们的释放由应用程序去控制，一般一个new就对应了一个delete。如果程序没有释放掉，那么在程序结束后，操作系统会自动回收
**自由存储区**
**全局/静态存储区**：全局变量和静态变量被分配到一块内存中=
**常量存储区**：存放的是常量，不允许修改
**代码区**：存放函数体的二进制代码
### 内存泄漏
![[Pasted image 20231007093340.png]]
#### 什么是内存泄漏
内存泄漏（Memory Leak）是指在程序运行过程中，程序分配的内存空间没有被正确释放，导致这些内存空间变得不可访问且不可用，从而浪费了系统的内存资源。
内存泄漏通常是由于程序员未正确管理动态分配的内存而引起的。

内存泄漏通常发生在以下情况下：

- 忘记释放动态分配的内存：使用 new、malloc、calloc 等动态分配内存后，需要使用 delete、free 等来释放这些内存，但有时程序员会忘记这么做。
- 丢失指向动态分配内存的指针：如果程序中的指针变量丢失了指向动态分配内存的引用，那么将无法释放这些内存，导致内存泄漏。
- 循环引用：在某些情况下，例如在使用智能指针时，循环引用可能导致内存泄漏，因为对象之间的引用计数永远不会达到零，从而导致内存无法释放。

#### 如何减少内存泄漏
1.良好的编码习惯，使用内存分配的函数，一但使用完毕之后就要记得使用对应的函数释放掉
2.将分配的内存的指针以链表的形式自行管理，使用之后从链表中删除，程序结束时可以检查链表
3.使用智能指针
4.使用常见插件，ccmalloc

### new/delete、malloc/free的异同
相同点：
- 都可用于内存的动态申请和释放

不同点
- 前者是C++运算符，后者是c/c++语言标准库函数
- new自动计算要分配空间大小，malloc需要手工计算
- new是类型安全的，malloc不是：
  ```C++
  int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译无错误
```
- 后者需要库文件支持，前者不用
- new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

### 被free回收的内存是立即返还给操作系统吗？
不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

### this指针
- this指针是类的指针，指向对象的首地址
- this指针只能在成员函数中使用，在全局函数、静态成员函数中不能使用this
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置

#### this的作用
当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。

#### this的使用
在类的非静态成员函数中返回类对象本身的时候，直接使用`return *this`

### 字节对齐问题
#### 什么是字节对齐
字节对齐（Byte Alignment）是指在计算机中存储数据时，为了提高访问速度和硬件的效率，要求数据结构从特定的地址开始存放，并且按照某种规定的字节长度的整数倍对齐存放。

#### 为什么需要字节对齐
需要字节对齐的根本原因在于CPU访问数据的效率问题
比如：
![[Pasted image 20231007095147.png]]

#### alignas与alignof
C++11以后引入的关键字，其中alignof可以计算出类型的对齐的方式，alignas可以指定结构体的对齐方式

### 如何用代码判断大小端存储
大端存储：字数据的高字节存储在低位地址中
小端存储：字数据的低字节存储在低位地址中

![[Pasted image 20240328143319.png]]
```C++
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

### 浅拷贝和深拷贝
浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

### `malloc`、`calloc`、`realloc`内存申请函数
在C和C++中，有几个常用的函数可用于动态分配内存，以便在运行时创建和管理内存块。这些函数包括 `malloc`、`calloc` 和 `realloc`。以下是它们的介绍和使用方法：

1. **malloc**（Memory Allocation）：
   - `malloc` 函数用于分配指定大小的内存块，并返回指向该内存块的指针。
   - 它接受一个参数，即要分配的字节数，返回一个 `void*` 类型的指针。
   - 分配的内存块的内容不会被初始化，它们可以包含任何值。
   - 如果分配失败，`malloc` 返回 `NULL`。

   示例：
   ```c
   int* arr = (int*)malloc(5 * sizeof(int));
   if (arr != NULL) {
       // 成功分配内存
       // 使用arr来操作分配的内存
       free(arr); // 释放内存
   } else {
       // 分配失败
   }
   ```

2. **calloc**（Contiguous Allocation）：
   - `calloc` 函数用于分配指定数量和大小的连续内存块，并返回指向该内存块的指针。
   - 它接受两个参数，即要分配的元素数量和每个元素的字节数，返回一个 `void*` 类型的指针。
   - 分配的内存块会被初始化为零。
   - 如果分配失败，`calloc` 返回 `NULL`。

   示例：
   ```c
   int* arr = (int*)calloc(5, sizeof(int));
   if (arr != NULL) {
       // 成功分配内存，并且内存已被初始化为0
       // 使用arr来操作分配的内存
       free(arr); // 释放内存
   } else {
       // 分配失败
   }
   ```

3. **realloc**（Reallocate Memory）：
   - `realloc` 函数用于重新分配已分配内存的大小。
   - 它接受两个参数，即原始内存块的指针和新的字节数，返回一个指向重新分配内存块的指针。
   - `realloc` 还可以用于将一个已分配的内存块扩展或缩小到新的大小。
   - 如果分配失败，`realloc` 返回 `NULL`。如果分配成功，原始内存块会被释放。

   示例：
   ```c
   int* arr = (int*)malloc(5 * sizeof(int));
   if (arr != NULL) {
       // 成功分配内存
       // 使用arr来操作分配的内存

       // 重新分配内存大小为10个int
       int* new_arr = (int*)realloc(arr, 10 * sizeof(int));
       if (new_arr != NULL) {
           // 重新分配成功
           arr = new_arr; // 更新指针
       } else {
           // 重新分配失败，但原始内存仍然有效
       }

       free(arr); // 释放内存
   } else {
       // 分配失败
   }
   ```

请注意，使用这些函数分配内存后，必须使用 `free` 函数来释放内存，以防止内存泄漏。

