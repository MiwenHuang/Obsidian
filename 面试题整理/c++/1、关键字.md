### 1. `const`作用
- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为常量指针、指针常量、指向常量的常量指针
```cpp
#include <iostream>
using namespace std;

int main()
{
    char greeting[] = "hello world";
    char greeting2[] = "hello world";
    const char* p1 = greeting;//常量指针，指向常量字符的指针，可以改变指向，但是不能改变所指向的内容
    p1 = greeting2;
    // p1[0] = "H";  报错
    char* const p2 = greeting;//指针常量，它的指针指向不可以改变，但是可以改变指向的内容
    // p2 = greeting2;  报错
    p2[6] = 'W';
    const char* const p3 = greeting;//指向常量的常量指针
    // p3 = greeting2;
    // p3[1] = 'E';
    return 0;
}
```
- 修饰引用：一般用于函数的形参，避免函数对形参值的修改
- 常函数，只能函数的数据不能修改
- 常对象，常对象只能调用常函数

### 2. 宏定义和`const`
1. 字符替换：
	- 宏定义是一种字符替换机制，它通过预处理器将宏名称替换为其定义的文本。
	- const 常量是具有明确数据类型和值的标识符。
2. 预处理器处理：
	- 宏定义是在预处理阶段由预处理器处理的，它们在源代码编译之前被展开。
	- const 常量是在编译阶段处理的，它们具有类型和作用域。
3. 无类型安全检查：
	- 宏定义不进行类型安全检查，因此可能引入潜在的类型错误。
	- const 常量具有明确的数据类型，提供了类型安全性，编译器可以执行类型检查。
4. 不分配内存：
	- 宏定义不分配内存，它们只是简单的文本替换。
	- const 常量分配内存，用于存储其值，并在程序运行时使用该内存。
5. 存储在代码段：
	- 宏定义的值通常嵌入在代码中，存储在代码段（可执行文件的一部分）。
	- const 常量的值通常存储在数据段或栈中，具有运行时内存分配。
6. 可以通过 \#undef 取消：
	- 使用\#undef 预处理指令可以取消宏定义，使其不再有效。
	- const 常量不可以取消，因为它们在编译期间具有固定的值和类型。

### 3. `static作用`
1. 定义变量
	**静态全局变量：** 作用于本文件，每次函数调用该变量都会被初始化
	**局部变量：** 生命周期不会随着函数结束而结束，直到程序结束，但是在函数外面不能使用该变量，只能在函数中使用，该变量是有记忆的，会记住上面的值。该变量只被初始化一次
2. 定义函数
	在函数返回类型前面加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件使用。
3. 定义类中的静态成员变量
	在类中的静态成员变量它即可以被当做全局变量那样存储，但又被隐藏与类中，类中的静态成员变量拥有一块独立的储存空间，不会占用类中的空间，所有的对象都共享该静态成员，也就是说，只要有对象改变了这个值，那么其他对象就会受影响
	**注意**：**静态数据成员不能在类中初始化，在类中只是声明，而不是定义**，静态数据必须要定义之后才能使用，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在类的构造函数中初始化该成员，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化
4. 定义类中的静态成员函数(只能访问静态成员变量)
	静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据成员都共享这一块静态存储空间
	**注意**：静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问，即不能在静态函数里面使用this指针

### 4. `this`指针
1. this指针是一个指向当前对象的指针，它在类的成员函数中自动创建并可直接使用。
2. this是一个右值，所以不能取得this的地址。
3. this主要用于区分成员变量和局部变量的歧义，当成员变量和局部变量同名的时候，可以使用"`this->`"来指明成员变量。
4. this 指针不能用于静态成员函数，因为静态成员函数不与特定对象相关联，而是与类本身相关联。

### 5. `inline`内联函数
#### 特征
* 相当于把内联函数里面的内容写在调用内联函数处；
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。
```cpp
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```
#### 编译器对 inline 函数的处理步骤

1. 将 inline 函数体复制到 inline 函数调用点处； 
2. 为所用 inline 函数中的局部变量分配内存空间； 
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优缺点
优点
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

#### 虚函数可以使用内联函数吗
- 虚函数可以使内联函数，但是当虚函数表现多态性的时候不能内联。因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性的时候不可以内联
虚函数内联使用
```cpp
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```

### 7. volatile（预处理）
**作用** ：告诉编译器这个变量是容易发生变化的，不能对该变量进行优化，每次取值都必须从内存中取值而不是使用之前的缓存值
常见场景：
- 中断：中断程序会修改其他程序中使用的变量
- 多线程使用共享变量
- 硬件寄存器

### 8. assert()

断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

assert() 使用

```cpp
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```

#### 为什么用assert不用if呢
assert用于帮助开发者在开发和测试过程中发现和解决问题，在生产环境中不会引入性能开销。if用于编写程序的正常逻辑，在运行时会引入一些性能开销。

### 9. sizeof()
#### `sizeof()`和`strlen()`的区别
首先`sizeof`是关键字，strlen是函数，sizeof用来计算占用内存大小，strlen是用来计算字符串的长度，
特别是对于需不需要包含\\0问题：
Sizeof是需要给\\0计算空间的，strlen是不需要，
sizeof是在编译的时候计算的，而strlen是在运行的时候计算

#### 求指针大小
在32位机器下，对于sizeof(指针变量)都是4个字节
引申：求引用的大小？引用的大小和数据类型有关

#### `sizeof(a++)`
```CPP
 int a = 2;
 printf("%d\n",sizeof(a++)); //4
 printf("%d\n",a);	// a = 2
```
注意：对于sizeof只会求所占内存大小，不会进行表达式运算


### 10. 如何判断一段程序是由C编译器还是由C++编译器编译的？
```CPP
#ifdef __cplusplus
	cout<<"C++";
#else cout<<"c";
#endif
```

### 11. explicit关键字
`explicit`关键字通常用于在类的构造函数前面，用来标识构造函数是否可以进行隐式类型转换。当一个构造函数被声明为 `explicit` 时，它不能用于隐式地将一个参数类型转换为类的对象类型。

```C++
class MyClass {
public:
    explicit MyClass(int x) {
        // 构造函数的实现
    }
};

int main() {
    MyClass obj = 42; // 错误，禁止隐式转换
    MyClass obj2(42); // 正确，显式调用构造函数
    return 0;
}

```
在C++中，如果一个类有一个带参数的构造函数，但没有定义默认构造函数（无参数构造函数），并且你希望允许使用带参数的构造函数进行对象创建，同时也希望保留默认构造函数，你可以在带参数的构造函数前使用 `explicit `关键字。
```C++
#include <iostream>

class MyClass {
public:
 // 默认构造函数（无参数构造函数）
    MyClass() {
        std::cout << "Default Constructor" << std::endl;
    }
    // 带参数的构造函数
    explicit MyClass(int value) {
        std::cout << "Parameterized Constructor with value: " << value << std::endl;
    }
};

int main() {
    // 允许使用默认构造函数创建对象
    MyClass obj1;

    // 允许使用带参数的构造函数创建对象
    MyClass obj2(42);

    return 0;
}

```

### 12. continue、break、goto、return
- continue：只能用于循环语句。continue作用是跳过本次循环中尚未执行的语句，立即进行下一次循环条件判定。简单来说就是仅仅结束本次循环
- break：只用用于循环语句或者switch语句，会使最近包含break语句跳出。
- return：结束当前循环，退出函数，用在函数体中，返回特定值
- goto：无条件跳转

### 13. Struct(c与c++的区别)
- 在c中，struct只能包含数据成员，不能包含数据成员函数，
- c语言结构体的数据成员默认是public的，并且不能修改权限。C++中权限可以修改
- c语言结构体不可以继承，c++可以继承
- 在c中不可以初始化数据成员，c++可以初始化

#### PS：c++中空结构体大小为1字节，c中为0

### 14. class和struct的区别
1. 访问权限：class作为对象的实现体。默认是私有访问，而struct是作为数据结构的实现体，是共有访问
2. 继承权限：class默认是private，struct默认是public
3. class可以用于定义模板，但是struct不能

### 15. Union(联合体)
#### 联合体和结构体的区别
- 结构体允许存储不同类型的成员，每个成员有独立的内存空间。
- 联合体允许在相同的内存位置存储不同类型的成员，但所有成员共享同一块内存。
- 联合体的大小等于最大成员的大小，而结构体的大小等于所有成员大小之和。
#### 联合体可以用来判断大小端问题

### 16. Enum
里面未被初始化的变量会自动加1：
```C++
#include <iostream>

enum Color {
    RED,    // 默认值为 0
    GREEN,  // 默认值为 1
    BLUE    // 默认值为 2
};

int main() {
    std::cout << "RED: " << RED << std::endl;
    std::cout << "GREEN: " << GREEN << std::endl;
    std::cout << "BLUE: " << BLUE << std::endl;

    return 0;
}

```

### 17. Typedef
#### typedef和\#define的区别
- `#define`是C语言中定义的语法，是预处理指令，在预处理时进行简单的字符串替换，不做正确性检查，只有在编译阶段已被展开的源程序才会发现可能的错误并报错
- `typedef`是关键字，在编译处理阶段，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。

### 18.extern（链接阶段）
c++中关键字`extern`用于声明外部变量或函数，它告诉编译器该变量或函数是在其他文件定义的，而不是在当前文件定义的。`extern`关键字通常用于解决多个源文件之间的变量和函数共享的问题。


### 19. register
可以使用 register 关键字来建议编译器将某个变量存储在CPU寄存器中，以提高对该变量的访问速度。

注意：
- register只是一个建议，编译器不一定会遵循这个建议
- 不能对寄存器的变量取地址
- 已经不建议使用。

### 20. auto
一般情况下，没有特别说明的局部变量都默认是`auto`类型，存储在栈中。auto关键字用于c++类型推导

### 21. new/malloc、delete/free
- 首先`new\delete`是运算符，而`malloc/free`是函数
- `new`先为对象申请内存空间，然后调用构造函数进行初始化，delete调用析构函数释放内存
- malloc只是申请内存空间并不能调用构造函数进行初始化，同理free也只是释放内存
- malloc的返回值需要强转为自己申请的内存指针，而new不需要
- malloc需要指定申请内存的内存大小

### 22.左值和右值
`左值`：
左值通常是标识符或表达式，其值存储在内存中的一个具体位置。
左值可以出现在赋值运算符的左边或右边
左值通常代表具名的变量，例如，普通变量、数组元素、类成员等都是左值。
示例：int x = 42; 中的 x 是一个左值。
++i、--i属于左值
i++、i--属于右值

`右值`：
右值通常是临时的、无法被修改的表达式的结果，其值在计算后可能没有明确定义的内存位置。
右值不能出现在赋值运算符的左边，因为它们没有一个确定的内存地址，不可被修改。
右值通常是常量、临时表达式的结果等。
示例：int y = 10 + 5; 中的 10 + 5 是一个右值。





