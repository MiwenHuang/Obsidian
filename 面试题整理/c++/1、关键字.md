### `const`作用
- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为常量指针、指针常量、指向常量的常量指针
```cpp
#include <iostream>
using namespace std;

int main()
{
    char greeting[] = "hello world";
    char greeting2[] = "hello world";
    const char* p1 = greeting;//常量指针，指向常量字符的指针，可以改变指向，但是不能改变所指向的内容
    p1 = greeting2;
    // p1[0] = "H";  报错
    char* const p2 = greeting;//指针常量，它的指针指向不可以改变，但是可以改变指向的内容
    // p2 = greeting2;  报错
    p2[6] = 'W';
    const char* const p3 = greeting;//指向常量的常量指针
    // p3 = greeting2;
    // p3[1] = 'E';
    return 0;
}
```
- 修饰引用：一般用于函数的形参，避免函数对形参值的修改
- const修饰成员函数，const对象不可调用非const成员函数，非const对象可以调用
- const修饰成员变量，只能在构造函数进行初始化


### 宏定义和`const`
1. 字符替换：
	- 宏定义是一种字符替换机制，它通过预处理器将宏名称替换为其定义的文本。
	- const 常量是具有明确数据类型和值的标识符。
2. 预处理器处理：
	- 宏定义是在预处理阶段由预处理器处理的，它们在源代码编译之前被展开。
	- const 常量是在编译阶段处理的，它们具有类型和作用域。
3. 无类型安全检查：
	- 宏定义不进行类型安全检查，因此可能引入潜在的类型错误。
	- const 常量具有明确的数据类型，提供了类型安全性，编译器可以执行类型检查。
4. 不分配内存：
	- 宏定义不分配内存，它们只是简单的文本替换。
	- const 常量分配内存，用于存储其值，并在程序运行时使用该内存。
5. 存储在代码段：
	- 宏定义的值通常嵌入在代码中，存储在代码段（可执行文件的一部分）。
	- const 常量的值通常存储在数据段或栈中，具有运行时内存分配。
6. 可以通过 \#undef 取消：
	- 使用\#undef 预处理指令可以取消宏定义，使其不再有效。
	- const 常量不可以取消，因为它们在编译期间具有固定的值和类型。

### `static作用`
- 不加static的全局变量和函数都有全局可见性，可以在其他文件中使用，加了之后只能在文件所在的编译模块中使用
- 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用
- static成员变量只与类关联，定义时分配空间，不能在类中初始化，必须在类定义体外初始化，可以被非static成员函数任意访问
- static成员函数，不具有this指针，无法访问类对象的非static成员变量和非static成员函数

### `this`指针
1. this指针是一个指向当前对象的指针，它在类的成员函数中自动创建并可直接使用。
2. this是一个右值，所以不能取得this的地址。
3. this主要用于区分成员变量和局部变量的歧义，当成员变量和局部变量同名的时候，可以使用"`this->`"来指明成员变量。
4. this 指针不能用于静态成员函数，因为静态成员函数不与特定对象相关联，而是与类本身相关联。

### `inline`内联函数
#### 特征
* 相当于把内联函数里面的内容写在调用内联函数处；
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。
```cpp
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```
#### 编译器对 inline 函数的处理步骤

1. 将 inline 函数体复制到 inline 函数调用点处； 
2. 为所用 inline 函数中的局部变量分配内存空间； 
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优缺点
优点
1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点
1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

### volatile（预处理）
**作用** ：告诉编译器这个变量是容易发生变化的，不能对该变量进行优化，每次取值都必须从内存中取值而不是使用之前的缓存值
常见场景：
- 中断：中断程序会修改其他程序中使用的变量
- 多线程使用共享变量
- 硬件寄存器

### mutable
mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要**在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置**。

### assert()
断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

assert() 使用

```cpp
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```

#### 为什么用assert不用if呢
assert用于帮助开发者在开发和测试过程中发现和解决问题，在生产环境中不会引入性能开销。if用于编写程序的正常逻辑，在运行时会引入一些性能开销。

### sizeof()
#### `sizeof()`和`strlen()`的区别
首先`sizeof`是关键字，strlen是函数，sizeof用来计算占用内存大小，strlen是用来计算字符串的长度，
特别是对于需不需要包含\\0问题：
Sizeof是需要给\\0计算空间的，strlen是不需要，
sizeof是在编译的时候计算的，而strlen是在运行的时候计算

#### 求指针大小
在32位机器下，对于sizeof(指针变量)都是4个字节
引申：求引用的大小？引用的大小和数据类型有关

#### `sizeof(a++)`
```CPP
 int a = 2;
 printf("%d\n",sizeof(a++)); //4
 printf("%d\n",a);	// a = 2
```
注意：对于sizeof只会求所占内存大小，不会进行表达式运算

### strcpy和memcpy的区别是什么
1. 复制内容不同，strcpy只能复制字符串，而memcpy可以复制任何内容，例如字符数组、整型、结构体、类等
2. 复制方法不同。strcpy不需要指定长度，他遇到被复制的字符的串结束符“\0”才结束，所以容易溢出。memcpy则是根据其disengage参数决定复制的长度
3. 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型时则一般用memcpy



### 如何判断一段程序是由C编译器还是由C++编译器编译的？
```CPP
#ifdef __cplusplus
	cout<<"C++";
#else cout<<"c";
#endif
```

### explicit关键字
`explicit`关键字通常用于在类的构造函数前面，用来标识构造函数是否可以进行隐式类型转换。当一个构造函数被声明为 `explicit` 时，它不能用于隐式地将一个参数类型转换为类的对象类型。

```C++
class MyClass {
public:
    explicit MyClass(int x) {
        // 构造函数的实现
    }
};

int main() {
    MyClass obj = 42; // 错误，禁止隐式转换
    MyClass obj2(42); // 正确，显式调用构造函数
    return 0;
}

```
在C++中，如果一个类有一个带参数的构造函数，但没有定义默认构造函数（无参数构造函数），并且你希望允许使用带参数的构造函数进行对象创建，同时也希望保留默认构造函数，你可以在带参数的构造函数前使用 `explicit `关键字。
```C++
#include <iostream>

class MyClass {
public:
 // 默认构造函数（无参数构造函数）
    MyClass() {
        std::cout << "Default Constructor" << std::endl;
    }
    // 带参数的构造函数
    explicit MyClass(int value) {
        std::cout << "Parameterized Constructor with value: " << value << std::endl;
    }
};

int main() {
    // 允许使用默认构造函数创建对象
    MyClass obj1;

    // 允许使用带参数的构造函数创建对象
    MyClass obj2(42);

    return 0;
}

```

### continue、break、goto、return
- continue：只能用于循环语句。continue作用是跳过本次循环中尚未执行的语句，立即进行下一次循环条件判定。简单来说就是仅仅结束本次循环
- break：只用用于循环语句或者switch语句，会使最近包含break语句跳出。
- return：结束当前循环，退出函数，用在函数体中，返回特定值
- goto：无条件跳转

### Struct(c与c++的区别)
- 在c中，struct只能包含数据成员，不能包含数据成员函数，
- c语言结构体的数据成员默认是public的，并且不能修改权限。C++中权限可以修改
- c语言结构体不可以继承，c++可以继承
- 在c中不可以初始化数据成员，c++可以初始化

#### PS：c++中空结构体大小为1字节，c中为0

### class和struct的区别
1. 访问权限：class作为对象的实现体。默认是私有访问，而struct是作为数据结构的实现体，是共有访问
2. 继承权限：class默认是private，struct默认是public
3. class可以用于定义模板，但是struct不能

### Union(联合体)
#### 联合体和结构体的区别
- 结构体允许存储不同类型的成员，每个成员有独立的内存空间。
- 联合体允许在相同的内存位置存储不同类型的成员，但所有成员共享同一块内存。
- 联合体的大小等于最大成员的大小，而结构体的大小等于所有成员大小之和。
#### 联合体可以用来判断大小端问题

### Enum
里面未被初始化的变量会自动加1：
```C++
#include <iostream>

enum Color {
    RED,    // 默认值为 0
    GREEN,  // 默认值为 1
    BLUE    // 默认值为 2
};

int main() {
    std::cout << "RED: " << RED << std::endl;
    std::cout << "GREEN: " << GREEN << std::endl;
    std::cout << "BLUE: " << BLUE << std::endl;

    return 0;
}

```

### Typedef
#### typedef和\#define的区别
- `#define`是C语言中定义的语法，是预处理指令，在预处理时进行简单的字符串替换，不做正确性检查，只有在编译阶段已被展开的源程序才会发现可能的错误并报错
- `typedef`是关键字，在编译处理阶段，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。

### extern（链接阶段）
c++中关键字`extern`用于声明外部变量或函数，它告诉编译器该变量或函数是在其他文件定义的，而不是在当前文件定义的。`extern`关键字通常用于解决多个源文件之间的变量和函数共享的问题。


### register
可以使用 register 关键字来建议编译器将某个变量存储在CPU寄存器中，以提高对该变量的访问速度。

注意：
- register只是一个建议，编译器不一定会遵循这个建议
- 不能对寄存器的变量取地址
- 已经不建议使用。

### C++的四种强制转换
#### reinterpret_cast
`reinterpret_cast<type-id> (expression)`
type-id必须是一个指针、引用、算数类型、函数指针或成员指针。用于类型之间进行强制转换

#### const_cast
`const_cast<type_id> (expression)`
用法：
- 常量指针被转化为非常量指针，并且仍然指向原来的对象
- 常量引用被转换为非常量的引用，并且指向原来的对象
- const_cast一般用于修改底指针。如const char \*p

#### static_cast
`static_cast < type-id > (expression)`
用法：
- 用于类层次结构中基类和派生类之间指针或引用的转换
	- 进行上行转换(把派生类的指针或引用转换成基类)是安全的
	- 下行转换没有动态类型转换，是不安全的
- 用于基本数据类型之间的转换，如把int转换为char，把int转换成enum。这种转换的安全性也要开发人员来保证
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转换成void类型

#### dynamic_cast
有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
`dynamic_cast <type-id> (expression)`
该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*
如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

dynamic_cast运算符可以在执行期决定真正的类型，**也就是说expression必须是多态类型**。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）




