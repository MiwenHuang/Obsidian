### 1. 什么是面向对象
面向对象是一种编程思想，把一切东西看成是一个对象，每个对象拥有自己的属性，把对象拥有的属性变量和操作这些属性变量的函数打包成一个类表示

### 2. 面向对象和面向过程的区别
面向过程：依照业务逻辑从上到下写代码
面向对象：将数据与函数绑定在一起，进行封装，对象理论上是不能直接操作数据，只能通过对应的函数里面的数据，这样能够更快速的开发程序，减少重复代码的重写过程

### 3. 面向对象的三大特征
封装 继承 多态

#### 封装
将对象的状态和行为封装在一起，对外部隐藏对象的内部实现细节。通过访问控制符（如public、private、protected），对象可以控制哪些部分对外可见。

#### 继承
对象的一个新类可以从现有的类中派生，保留了父类的特性。继承解决了代码可重用性的问题，在子类里面可以添加属于自己的新的函数或者变量，使得更加符合需求

继承方式：
共有、私有、保护
![[Pasted image 20231215105823.png]]

#### 多态
 允许不同类型的对象对相同的操作做出不同的响应。多态性使得代码更加灵活，能够处理多种不同类型的对象。
 
重写是动态多态，重载是静态多态（编译器在编译期完成）
重写需要满足条件：
1）虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
2）通过基类类型的指针或引用来调用虚函数

### 4. 什么是深拷贝？什么是浅拷贝？
**浅拷贝**：简单的复制成员的值，包括指针成员的地址。多个对象可能共享相同的资源，容易存在潜在的问题，如指针悬挂

浅拷贝会导致指针悬挂（Dangling Pointers）的问题，这是因为浅拷贝只是简单地复制指针的值，而不是复制指针指向的实际数据。这可能导致多个指针指向相同的内存地址，当其中一个指针释放了该内存，其他指针就变成悬挂指针，指向无效的内存。

**深拷贝**：深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

### 5. 友元函数
友元的目的是让一个函数或者类访问另一个类中的私有成员，关键字为`friend`

友元函数的三种实现：
1. 全局函数做友元
   ```CPP

class Room
{
    friend void GoodGay(Room *room);
private:
    /* data */
    string bedroom;
public:
    string livingroom;;
    Room(/* args */){
        this->livingroom="客厅";
        this->bedroom="卧室";
    }
};

void GoodGay(Room *room){
    cout<<"你的好朋友正在访问:"<<room->livingroom<<endl;
    cout<<"你的好朋友正在访问:"<<room->bedroom<<endl;
}

int main(){
    Room room;
    GoodGay(&room);
    return 1;
}
```

2. 类做友元
   ```CPP
   class Room;
class GoodFriends{
public :
    GoodFriends();
    void visit();
    Room *room;
};

class Room{
//告诉编译器，GoodFriends是Room的好朋友，可以访问到Room类的私有内容
    friend GoodFriends;
public:
    Room();
    string livingroom;

private:   
    string bedroom;
};

//类外写成员函数
Room::Room(){
    livingroom="客厅";
    bedroom="卧室";
}

GoodFriends::GoodFriends(){
    // 创建房间的对象
    room=new Room;
}

void GoodFriends::visit(){
    cout<<"好朋友访问了："<<room->livingroom<<endl;
    cout<<"好朋友访问了："<<room->bedroom<<endl;
    
}

void test(){
    GoodFriends gf;
    gf.visit();
}
int main(){
    test();
    return 1;
}
```
3. 成员函数做友元
   ```C++
class Room;
class GoodFriends{
public :
    GoodFriends();
    void visit();//让visit访问到room中的私有成员
    Room *room;


};

class Room{

    // 告诉编译器，这是GoodFriends类下的visit成员函数作为本类的好朋友，可以访问他的私有内容 
    friend void GoodFriends::visit();
public:
    Room();
    string livingroom;

private:   
    string bedroom;
};

//类外实现成员函数
Room::Room(){
    livingroom="客厅";
    bedroom="卧室";
}

GoodFriends::GoodFriends(){
    // 创建房间的对象
    room=new Room;
}

void GoodFriends::visit(){
    cout<<"好朋友访问了："<<room->livingroom<<endl;
    cout<<"好朋友访问了："<<room->bedroom<<endl;
    
}

void test(){
    GoodFriends gf;
    gf.visit();
}
int main(){
    test();
    return 1;
}
```

友元函数的缺点：破坏了类的封装性和数据的透明性

### 6. 什么函数不能被声明为虚函数
![[附件/Pasted image 20231023170825.png]]


