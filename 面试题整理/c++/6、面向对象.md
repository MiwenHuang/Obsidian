### 什么是面向对象
面向对象是一种编程思想，把一切东西看成是一个对象，每个对象拥有自己的属性，把对象拥有的属性变量和操作这些属性变量的函数打包成一个类表示

### 面向对象和面向过程的区别
面向过程：依照业务逻辑从上到下写代码
面向对象：将数据与函数绑定在一起，进行封装，对象理论上是不能直接操作数据，只能通过对应的函数里面的数据，这样能够更快速的开发程序，减少重复代码的重写过程

### 面向对象的三大特征
#### 封装
将对象的状态和行为封装在一起，对外部隐藏对象的内部实现细节。通过访问控制符（如public、private、protected），对象可以控制哪些部分对外可见。

#### 继承
对象的一个新类可以从现有的类中派生，保留了父类的特性。继承解决了代码可重用性的问题，在子类里面可以添加属于自己的新的函数或者变量，使得更加符合需求

继承方式：
共有、私有、保护
![[Pasted image 20231215105823.png]]

#### 多态
 允许不同类型的对象对相同的操作做出不同的响应。多态性使得代码更加灵活，能够处理多种不同类型的对象。
 
重写是动态多态，重载是静态多态（编译器在编译期完成）
重写需要满足条件：
1）虚函数。基类中必须有虚函数，在派生类中必须重写虚函数。
2）通过基类类型的指针或引用来调用虚函数

### 类如何实现只能静态分配和动态分配
1. 前者把new 、delete运算符重载为private属性，后者把构造函数和析构函数设为protected属性，再用子类来动态创建
2. 创建类的对象有两种方式
   - 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；
   - 动态建立，A \*p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；

###  友元函数
友元的目的是让一个函数或者类访问另一个类中的私有成员，关键字为`friend`

友元函数的三种实现：
1. 全局函数做友元
   ```CPP

class Room
{
    friend void GoodGay(Room *room);
private:
    /* data */
    string bedroom;
public:
    string livingroom;;
    Room(/* args */){
        this->livingroom="客厅";
        this->bedroom="卧室";
    }
};

void GoodGay(Room *room){
    cout<<"你的好朋友正在访问:"<<room->livingroom<<endl;
    cout<<"你的好朋友正在访问:"<<room->bedroom<<endl;
}

int main(){
    Room room;
    GoodGay(&room);
    return 1;
}
```

2. 类做友元
   ```CPP
   class Room;
class GoodFriends{
public :
    GoodFriends();
    void visit();
    Room *room;
};

class Room{
//告诉编译器，GoodFriends是Room的好朋友，可以访问到Room类的私有内容
    friend GoodFriends;
public:
    Room();
    string livingroom;

private:   
    string bedroom;
};

//类外写成员函数
Room::Room(){
    livingroom="客厅";
    bedroom="卧室";
}

GoodFriends::GoodFriends(){
    // 创建房间的对象
    room=new Room;
}

void GoodFriends::visit(){
    cout<<"好朋友访问了："<<room->livingroom<<endl;
    cout<<"好朋友访问了："<<room->bedroom<<endl;
    
}

void test(){
    GoodFriends gf;
    gf.visit();
}
int main(){
    test();
    return 1;
}
```
3. 成员函数做友元
   ```C++
class Room;
class GoodFriends{
public :
    GoodFriends();
    void visit();//让visit访问到room中的私有成员
    Room *room;


};

class Room{

    // 告诉编译器，这是GoodFriends类下的visit成员函数作为本类的好朋友，可以访问他的私有内容 
    friend void GoodFriends::visit();
public:
    Room();
    string livingroom;

private:   
    string bedroom;
};

//类外实现成员函数
Room::Room(){
    livingroom="客厅";
    bedroom="卧室";
}

GoodFriends::GoodFriends(){
    // 创建房间的对象
    room=new Room;
}

void GoodFriends::visit(){
    cout<<"好朋友访问了："<<room->livingroom<<endl;
    cout<<"好朋友访问了："<<room->bedroom<<endl;
    
}

void test(){
    GoodFriends gf;
    gf.visit();
}
int main(){
    test();
    return 1;
}
```

友元函数的缺点：破坏了类的封装性和数据的透明性

