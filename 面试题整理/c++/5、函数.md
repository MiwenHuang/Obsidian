### C++的多态如何实现？
在基类的函数前加上**virtual**关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。

实现多态过程：
- 首先编译器发现类当中有虚函数，会自动给每个含有需函数的类生成一个虚函数表，该表是一个数组，虚函数里保存了虚函数的入口地址
- 编译器会在每个对象的前4个字节种保存一个虚指针表，即vptr。如下图。虚表指针指向对象所属类的虚函数表。在构造函数中，根据对象的类型去初始化虚表指针，让虚表指针指向正确的虚函数表，从而在调用虚函数时，找到正确的函数
- 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

### 为什么析构函数必须是虚函数
析构函数必须是虚函数的主要原因涉及到C++中的多态性和继承。

如果析构函数不是虚函数，那么在使用基类指针指向派生类对象并调用 delete 进行删除时，只会调用基类的析构函数，而不会调用派生类的析构函数，这可能导致派生类资源泄漏

通过将基类的析构函数声明为虚函数，可以确保在使用基类指针删除派生类对象时，会先调用派生类的析构函数，然后再调用基类的析构函数。这样可以正确地释放派生类对象所占用的资源

### 为什么C++默认的析构函数不是虚函数
当类中有虚成员函数时，类会自动生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。

这样一来，就会占用额外的内存，当定义的类不被其他类继承时，这种内存开销无疑是浪费的

### 静态函数和虚函数的区别
类的静态函数是没有this指针的，也就是静态函数不属于对象，而是属于类。静态函数只有唯一一份，因此它的地址固定不变，所以在编译的时候就确定了运行时机，属于静态绑定。

但是虚函数就不一样了，当类中有虚函数的时候，类会自动生成虚函数表。虚函数表就是一个数组，每个元素存放的都是各个虚函数的地址。当基类指针指向派生类的对象的时候，代码在编译期间只对语法进行检测，但编译器无法得知这个指针调用的是那个函数，只有在程序运行的时候通过指针查看对象的虚函数表才能确定调用哪一个虚函数。简单来说就是 虚函数在运行的时候动态绑定。

### 4. 重载和重写
`重写`：
是指**派生类**中存在重写函数，函数名，参数，返回值类型必须和基类中被重写的函数一样，只是它们的函数体不一样，被重写的函数必须用virtual修饰
`重载`：
是指函数名相同，函数参数不同，不关心返回值类型
函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型

### 5. 虚函数表具体怎么实现运行是多态？
![[Pasted image 20231206164640.png]]

### 构造函数有几种，分别什么作用
构造函数的特点：
1. 函数名和类名必须一样，没有返回值
2. 构造函数可以重载
3. 当没有显式的定义构造函数时，系统会自己生成默认的构造函数

默认构造函数、普通构造函数、拷贝构造函数
1. 默认构造函数：没有参数的构造函数，如果在类中没有显式定义构造函数，编译器类new的内存，当删除基类指针时，并不是去删除继承类的内存，也就是说并没有去调用继承类的析构函数，很明显这不是我们想要的清理方式，我们希望是清理掉继承类内存和基类的内存，所以这个时候就需要析构函会自动生成一个默认构造函数。
主要作用是初始化对象的成员变量为默认值，确保对象创建后是可用的。

2. 普通构造函数：带有参数的构造函数，用于在创建对象时传递参数并初始化对象的成员变量。
主要作用是允许在创建对象时为对象提供不同的初值。

3. 拷贝构造函数用于在创建对象时，通过复制另一个对象的值来初始化新对象。它通常采用另一个对象的引用作为参数，然后复制该对象的成员变量的值到新对象。拷贝构造函数主要用于创建一个新对象，其成员变量与现有对象相同。

###  构造函数能否声明为虚函数或者纯虚函数，析构函数呢
析构函数：

- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
- 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
- **析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

构造函数：

- 根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.
- 虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。
### 基类的虚函数表存放在内存的什么区？一级虚表指针的初始化时间
首先：
虚函数表是全局共享的元素，所以不在栈区；
虚函数表类似于一维数组，不是程序代码所以不会在代码存储区；
虚函数表的大小在编译器就可以确定，即大小是在编译器时期确定的，不必动态分配内存存储虚函数表，所以不在堆中

因此最有可能去存储在全局数据区；
虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，也就是C++内存模型中的常量区

### 构造函数、析构函数、虚函数是否可声明为内联函数
首先 ，构造函数和析构函数声明为内联函数是没有意义的。
编译器并不真正堆声明为inline的构造和析构函数进行内敛操作，因为编译器会对构造函数和析构函数进行额外的操作，比如申请/释放内存，构造/析构对象，使得构造函数和析构函数看起来不精简。
其次，类的函数默认是inline型的，编译器也只会选择性的inline。

当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

### 类什么时候会析构？
1. 对象生命周期结束，被销毁时
2. delete指向对象的指针时；
3. 对象i时对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。
### 静态函数能定义为虚函数吗？
虚函数依靠虚表指针和虚函数表来处理，虚表指针是一个指针，在构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且虚表指针指向保存虚函数地址的虚函数表，对于静态函数，没有this指针，所以无法访问虚表指针

### 哪些函数不是虚函数？
首先，普通函数和友元函数都不属于类的成员函数，也不能被继承，所以没有虚函数的说法

静态函数不属于对象属于类，所以设置为虚函数没有意义

内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；

构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

### ## 为什么拷贝构造函数必须传引用不能传值？
 当你传递参数给函数时，如果你传递的是按值传递，实际上是将参数的副本传递给了函数。如果拷贝构造函数也是按值传递参数，那么在调用拷贝构造函数时，将会再次创建一个对象的副本，这样就会导致无限递归调用，最终导致栈溢出或程序崩溃
传递引用允许在函数中直接操作原始对象，而不是创建对象的副本。因此，拷贝构造函数应该接受对象的引用作为参数，以便在创建对象的副本时避免无限递归调用，并确保正确地复制对象的状态。
### 只定义析构函数，会自动生成哪些构造函数
编译器会自动生成拷贝构造函数和默认构造函数

### 说说一个类，默认会生成哪些函数
无参构造函数 拷贝构造函数 析构函数(非虚)

### c++对象的初始化顺序，有多重继承情况下的顺序
父类构造函数-》成员类对象构造函数-》自身构造函数


