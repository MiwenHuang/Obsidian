### 进程、线程和协程的区别和联系
#### 1. 进程（Process）：
- **定义**：进程是操作系统中的一个执行实例。每个进程都有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。
- **特点**：
    - 进程之间相互独立，一个进程的崩溃通常不会影响其他进程。
    - 进程间通信（IPC）相对复杂，通常需要通过操作系统提供的特殊机制来实现，如管道、消息队列、共享内存等。
    - 进程切换开销相对较大，因为需要保存和恢复完整的进程状态。
- **联系**：进程可以包含多个线程，每个线程共享相同的进程资源。
#### 2. 线程（Thread）：
- **定义**：线程是在进程内部独立执行的一段指令序列，是操作系统调度的基本单位。
- **特点**：
    - 线程共享进程的地址空间和资源，包括内存、文件句柄等。
    - 线程间通信相对容易，可以通过共享内存等方式进行。
    - 线程切换开销相对较小，因为不需要保存和恢复完整的进程状态，只需保存和恢复线程的部分状态。
- **联系**：线程是进程的一部分，一个进程可以包含多个线程。
#### 3. 协程（Coroutine）：
- **定义**：协程是一种用户态的轻量级线程，由程序员控制调度和状态保存/恢复。
- **特点**：
    - 协程的调度和切换是由程序员自行控制的，通常基于协程库提供的机制。
    - 协程可以在单线程内并发执行，因此不存在多线程的线程安全问题。
    - 协程间切换开销很小，因为切换时不涉及操作系统的介入，只需保存和恢复协程的状态。
- **联系**：协程是一种更轻量级的并发机制，可以在单线程内实现并发，也可以在多线程环境下使用。
#### 区别总结：
- 进程是系统资源分配的基本单位，拥有独立的内存空间和地址空间，进程切换开销大。
- 线程是进程内的执行单元，共享进程的资源，切换开销相对较小。
- 协程是一种轻量级的线程，由程序员控制调度，切换开销最小。

### 线程和进程的比较
1. 线程启动速度快，轻量级
2. 线程的系统开销小
3. 线程使用有一定难度，需要处理数据一致性问题
4. 同一线程共享有堆、全局变量、静态变量、指针、引用、文件等，而独自占用栈

### 一个进程可以创建多少线程，和什么有关？
- 如果是32位系统，用户态的虚拟空间只有3G，如果创建线程时分配的栈空间是10M，那么一个进程最多只能创建300个左右的线程
- 如果是64位系统，，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。

### 外中断与异常的区别？
外中断是指有CPU执行指令以外的时间引起的，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够用发送下一个输入输出请求。此外还有时钟中断、控制台中断等

而异常是由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

### 进程调度算法
| 调度算法            | 描述                                                     | 优点                   | 缺点                               |
| --------------- | ------------------------------------------------------ | -------------------- | -------------------------------- |
| 先来先服务 (FCFS)    | 非抢占式调度算法，按照请求的顺序进行调度。                                  | 有利于长作业，简单易实现。        | 短作业需要等待时间过长，可能导致长作业优先执行而饿死短作业。   |
| 短作业优先 (SJF)     | 非抢占式调度算法，按估计运行时间最短的顺序进行调度。                             | 短作业等待时间短，有利于短作业。     | 长作业可能会饿死，无法得到调度。                 |
| 最短剩余时间优先 (SRTN) | 抢占式调度算法，按剩余运行时间的顺序进行调度。                                | 最大程度上减少等待时间。         | 需要实时更新剩余时间，实现较为复杂。               |
| 时间片轮转           | 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，执行一个时间片。 | 公平，适用于多种类型的作业。       | 时间片大小对效率影响较大，可能导致进程切换频繁或实时性无法保证。 |
| 优先级调度           | 为每个进程分配一个优先级，按优先级进行调度。                                 | 可以根据进程的重要性或紧急程度进行调度。 | 低优先级的进程可能会长时间等待调度，可能导致饥饿。        |
| 多级反馈队列          | 设置多个队列，每个队列时间片大小不同。进程在第一个队列没执行完，就会被移到下一个队列。            | 适应性强，可以兼顾长作业和短作业。    | 需要调节多个参数，实现较为复杂。                 |
### 进程间通信方式
下面是对这些进程间通信方式的总结，包括它们的特点和适用场景：

| 进程间通信方式 | 特点                                                                                   | 适用场景                                                                                      |
|----------------|----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 无名管道       | - 半双工通信，只能在具有亲缘关系的进程之间使用。<br>- 数据单向流动。<br>- 通常用于父子进程间通信。 | 父子进程间通信，数据流动单向的场景。                                                          |
| 有名管道       | - 半双工通信，允许在没有亲缘关系的进程之间使用。<br>- 数据单向流动。<br>- 先进先出的通信方式。    | 不具有亲缘关系的进程间通信，且数据流动单向的场景。                                             |
| 共享内存       | - 映射一段能被多个进程访问的内存。<br>- 最快的 IPC 方式。<br>- 可以与信号量结合使用实现同步和通信。 | 需要高效的数据交换，且多个进程需要频繁访问共享数据的场景。                                       |
| 消息队列       | - 存放在内核中的消息链表，由消息队列标识符标识。<br>- 克服了其他通信方式的一些限制。<br>- 可以实现异步通信。  | 需要缓冲区大小不受限制，消息格式化，并且需要实现异步通信的场景。                                   |
| 套接字         | - 适用于不同机器间进程通信，也可在本地作为进程间通信方式。<br>- 提供全双工通信。<br>- 基于网络协议实现。 | 跨网络或本地进程间通信，需要全双工通信的场景。                                                   |
| 信号           | - 用于通知接收进程某个事件已经发生。<br>- 基于操作系统的信号机制。<br>- 可以在任何时刻发送给进程。       | 发送简单的通知信息，如进程终止、中断等事件的场景。                                               |
| 信号量         | - 用来控制多个进程对共享资源的访问。<br>- 可以实现进程、线程的同步和互斥访问。<br>- 常作为一种锁机制。  | 控制多个进程对共享资源的访问，实现进程同步和互斥访问的场景。                                      |

### 动态分区分配算法有哪几种？
| 算法   | 算法思想          | 分区排列顺序        | 优点                                  | 缺点                                   |
| ---- | ------------- | ------------- | ----------------------------------- | ------------------------------------ |
| 首次适应 | 从头到尾找适合的分区    | 空闲分区以地址递增次序排列 | 综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序 | 可能会产生较多的碎片，影响内存利用率。                  |
| 最佳适应 | 优先使用更小的分区     | 空闲分区以容量递增次序排列 | 更能满足大进程需求，保留更多大分区                   | 产生很多小碎片，难以利用，算法开销大，可能需要重新排序空闲分区队列    |
| 最坏适应 | 优先使用更大的分区     | 空闲分区以容量递减次序排列 | 减少难以利用的小碎片                          | 大分区容易被用完，不利于大进程，算法开销大，可能需要重新排序空闲分区队列 |
| 邻近适应 | 从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列 | 不用每次都从低地址的小分区开始检索，算法开销小             | 可能导致高地址的大分区被过度使用，影响内存利用率             |
### 虚拟技术
虚拟技术把一个物理实体转换为多个逻辑实体
时分复用技术：多个进程在同一个处理器上并发执行，让每个进程轮流占用处理器，每次只执行一个时间片并快速切换
空分复用技术：将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 进程状态的切换你知道多少？
![[Pasted image 20240407102639.png]]
- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源
应该注意以下内容：
- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

>